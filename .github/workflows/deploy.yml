name: Unified Deployment Pipeline

# This workflow provides a single, unified deployment pipeline that automatically
# detects the target environment based on the branch being deployed.

on:
  # Branch-based automatic deployments
  push:
    branches: [main, staging, renovations]
    paths:
      - "src/**"
      - "public/**"
      - "package.json"
      - "package-lock.json"
      - "Dockerfile"
      - "next.config.js"
      - "tsconfig.json"
      - "jest.config.js"
      - "eslint.config.mjs"
      - ".github/workflows/deploy.yml"
      - "terraform/**"
      - "ansible/**"

  # Manual deployment trigger for emergency situations
  workflow_dispatch:
    inputs:
      target_environment:
        description: "Override target environment (staging|production)"
        required: false
        type: choice
        options: [staging, production]
        default: "staging"
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        type: boolean
        default: false
      skip_tests:
        description: "Skip all tests (emergency only)"
        required: false
        type: boolean
        default: false

# Global environment variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

# Security: Restrict permissions to minimum required
permissions:
  contents: read
  packages: write
  deployments: write
  issues: write
  pull-requests: write

jobs:
  # Environment detection and setup
  detect-environment:
    name: Environment Detection
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      deploy_target: ${{ steps.detect.outputs.deploy_target }}
      should_build: ${{ steps.detect.outputs.should_build }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
      should_test: ${{ steps.detect.outputs.should_test }}

    steps:
      - name: Detect environment and deployment strategy
        id: detect
        run: |
          echo "ðŸ” Analyzing deployment context..."

          # Get branch name (handle both push and manual triggers)
          BRANCH_NAME="${{ github.ref_name }}"
          if [ -n "${{ github.event.inputs.target_environment }}" ]; then
            BRANCH_NAME="${{ github.event.inputs.target_environment }}"
            echo "Manual override: using branch $BRANCH_NAME"
          fi

          # Environment detection logic
          case "$BRANCH_NAME" in
            "main")
              ENVIRONMENT="production"
              DEPLOY_TARGET="production"
              SHOULD_BUILD="true"
              SHOULD_DEPLOY="true"
              SHOULD_TEST="true"
              ;;
            "staging")
              ENVIRONMENT="staging"
              DEPLOY_TARGET="staging"
              SHOULD_BUILD="true"
              SHOULD_DEPLOY="true"
              SHOULD_TEST="true"
              ;;
            "renovations")
              ENVIRONMENT="development"
              DEPLOY_TARGET="none"
              SHOULD_BUILD="true"
              SHOULD_DEPLOY="false"
              SHOULD_TEST="true"
              ;;
            *)
              echo "::error::Unsupported branch: $BRANCH_NAME"
              echo "Supported branches: main, staging, renovations"
              exit 1
              ;;
          esac

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deploy_target=$DEPLOY_TARGET" >> $GITHUB_OUTPUT
          echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "should_test=$SHOULD_TEST" >> $GITHUB_OUTPUT

          echo "ðŸ“‹ Deployment Configuration:"
          echo "  Branch: $BRANCH_NAME"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deploy Target: $DEPLOY_TARGET"
          echo "  Build: $SHOULD_BUILD"
          echo "  Deploy: $SHOULD_DEPLOY"
          echo "  Test: $SHOULD_TEST"

  # Quality checks and building
  quality-and-build:
    name: Quality Checks & Build
    runs-on: ubuntu-latest
    needs: [detect-environment]
    if: needs.detect-environment.outputs.should_build == 'true'

    # Set the environment for this job
    environment: ${{ needs.detect-environment.outputs.environment }}

    outputs:
      image_tag: ${{ github.ref_name }}-${{ github.sha }}
      image_digest: ${{ steps.build.outputs.digest }}
      test_results: ${{ steps.test.outputs.results }}
      build_success: ${{ steps.build.outcome }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Full history for proper tagging

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: "22.21.0"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run typecheck
        if: github.event.inputs.skip_tests != 'true'

      - name: Run security audit
        run: npm audit --audit-level moderate
        continue-on-error: true

      - name: Run unit tests
        id: test
        uses: ./.github/actions/test-runner
        if: github.event.inputs.skip_tests != 'true'
        with:
          test_type: unit
          environment: ${{ steps.detect.outputs.environment }}
          collect_coverage: true
          fail_fast: false

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results-${{ needs.detect-environment.outputs.environment }}
          path: |
            coverage/
            test-results/
            *.xml
          retention-days: 30

      - name: Fail on test failures (unless forced)
        if: steps.test.outcome == 'failure' && github.event.inputs.force_deploy != 'true'
        run: |
          echo "::error::Unit tests failed and force_deploy is not enabled"
          exit 1

      - name: Log in to Container Registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

  # Deployment job
  deploy:
    name: Deploy to ${{ needs.detect-environment.outputs.deploy_target }}
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.6"

      - name: Deploy application
        uses: ./.github/actions/deploy
        id: deployment
        with:
          environment: ${{ needs.detect-environment.outputs.environment }}
          image_tag: ${{ needs.quality-and-build.outputs.image_tag }}
          skip_tests: ${{ github.event.inputs.skip_tests || 'false' }}
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KEY_FINGERPRINT: ${{ secrets.SSH_KEY_FINGERPRINT }}
          SPACES_ACCESS_ID: ${{ secrets.SPACES_ACCESS_ID }}
          SPACES_SECRET_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          BREVO_API_KEY: ${{ secrets.BREVO_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          NEXT_PUBLIC_PRODUCTION_GA_ID: ${{ secrets.NEXT_PUBLIC_PRODUCTION_GA_ID }}
          ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Integration testing (staging only)
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy]
    if: needs.detect-environment.outputs.should_test == 'true' && needs.detect-environment.outputs.environment == 'staging' && github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Run integration tests
        uses: ./.github/actions/test-runner
        with:
          test_type: integration
          environment: staging
          app_url: https://staging.boximity.ca
          fail_fast: false
          timeout_minutes: 15

      - name: Run E2E tests
        uses: ./.github/actions/test-runner
        with:
          test_type: e2e
          environment: staging
          app_url: https://staging.boximity.ca
          fail_fast: false
          timeout_minutes: 20

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-results-${{ github.run_id }}
          path: |
            test-results/
            playwright-report/
          retention-days: 30

  # Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build, deploy, integration-tests]
    if: always() # Always run notifications

    steps:
      - name: Send deployment notifications
        uses: ./.github/actions/notify
        with:
          event_type: ${{ needs.deploy.result == 'success' && 'deployment-success' || 'deployment-failed' }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          workflow_run_id: ${{ github.run_id }}
          commit: ${{ github.sha }}
          triggered_by: ${{ github.actor }}
          deployment_details: |
            {
              "image_tag": "${{ needs.quality-and-build.outputs.image_tag }}",
              "image_digest": "${{ needs.quality-and-build.outputs.image_digest }}",
              "environment": "${{ needs.detect-environment.outputs.environment }}",
              "branch": "${{ github.ref_name }}",
              "build_success": "${{ needs.quality-and-build.outputs.build_success }}",
              "integration_tests": "${{ needs.integration-tests.result || 'skipped' }}",
              "timestamp": "${{ github.event.head_commit.timestamp }}"
            }
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
