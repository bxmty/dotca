name: Unified Deployment Pipeline

# This workflow provides a single, unified deployment pipeline that automatically
# detects the target environment based on the branch being deployed.

on:
  # Branch-based automatic deployments
  push:
    branches: [main, staging, renovations]
    paths:
      - "src/**"
      - "public/**"
      - "package.json"
      - "package-lock.json"
      - "Dockerfile"
      - "next.config.js"
      - "tsconfig.json"
      - "jest.config.js"
      - "eslint.config.mjs"
      - ".github/workflows/deploy.yml"
      - ".github/actions/deploy/action.yml"
      - "terraform/**"
      - "ansible/**"

  # Manual deployment trigger for emergency situations
  workflow_dispatch:
    inputs:
      target_environment:
        description: "Override target environment (staging|production)"
        required: false
        type: choice
        options: [staging, production]
        default: "staging"
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        type: boolean
        default: false
      skip_tests:
        description: "Skip all tests (emergency only)"
        required: false
        type: boolean
        default: false

# Global environment variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

# Security: Restrict permissions to minimum required
permissions:
  contents: read
  packages: write
  deployments: write
  issues: write
  pull-requests: write

jobs:
  # Check what files have changed to determine if we need to build
  check-changes:
    name: Check for App Changes
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.filter.outputs.app }}
      infra_changed: ${{ steps.filter.outputs.infra }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            app:
              - 'src/**'
              - 'public/**'
              - 'package.json'
              - 'package-lock.json'
              - 'Dockerfile'
              - 'next.config.js'
              - 'tsconfig.json'
              - 'jest.config.js'
              - 'eslint.config.mjs'
              - '.github/workflows/deploy.yml'
            infra:
              - 'terraform/**'
              - 'ansible/**'

  # Environment detection and setup
  detect-environment:
    name: Environment Detection
    runs-on: ubuntu-latest
    needs: [check-changes]
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      deploy_target: ${{ steps.detect.outputs.deploy_target }}
      should_build: ${{ steps.detect.outputs.should_build }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
      should_test: ${{ steps.detect.outputs.should_test }}
      should_promote: ${{ steps.detect.outputs.should_promote }}

    steps:
      - name: Detect environment and deployment strategy
        id: detect
        run: |
          echo "üîç Analyzing deployment context..."

          # Get branch name (handle both push and manual triggers)
          BRANCH_NAME="${{ github.ref_name }}"
          if [ -n "${{ github.event.inputs.target_environment }}" ]; then
            BRANCH_NAME="${{ github.event.inputs.target_environment }}"
            echo "Manual override: using branch $BRANCH_NAME"
          fi

          # Check what files have changed
          APP_CHANGED="${{ needs.check-changes.outputs.app_changed }}"
          INFRA_CHANGED="${{ needs.check-changes.outputs.infra_changed }}"

          echo "üìä Change Analysis:"
          echo "  App files changed: $APP_CHANGED"
          echo "  Infra files changed: $INFRA_CHANGED"

          # Environment detection logic
          case "$BRANCH_NAME" in
            "main")
              ENVIRONMENT="production"
              DEPLOY_TARGET="production"
              # Production: promote from staging, never build
              if [ "$APP_CHANGED" = "true" ] || [ -n "${{ github.event.inputs.target_environment }}" ]; then
                SHOULD_BUILD="false"
                SHOULD_PROMOTE="true"
                SHOULD_DEPLOY="true"
                SHOULD_TEST="true"
                echo "üöÄ Production deployment: will promote staging image"
              else
                SHOULD_BUILD="false"
                SHOULD_PROMOTE="false"
                SHOULD_DEPLOY="$INFRA_CHANGED"  # Deploy infra changes without rebuilding app
                SHOULD_TEST="false"
                echo "‚è≠Ô∏è  Skipping build/promotion: no app changes detected"
              fi
              ;;
            "staging")
              ENVIRONMENT="staging"
              DEPLOY_TARGET="staging"
              # Staging: promote from renovations, never build
              if [ "$APP_CHANGED" = "true" ] || [ -n "${{ github.event.inputs.target_environment }}" ]; then
                SHOULD_BUILD="false"
                SHOULD_PROMOTE="true"
                SHOULD_DEPLOY="true"
                SHOULD_TEST="true"
                echo "üöÄ Staging deployment: will promote renovations image"
              else
                SHOULD_BUILD="false"
                SHOULD_PROMOTE="false"
                SHOULD_DEPLOY="$INFRA_CHANGED"  # Deploy infra changes without rebuilding app
                SHOULD_TEST="false"
                echo "‚è≠Ô∏è  Skipping build/promotion: no app changes detected"
              fi
              ;;
            "renovations")
              ENVIRONMENT="development"
              DEPLOY_TARGET="none"
              # Renovations: build only (source of truth), never deploy
              if [ "$APP_CHANGED" = "true" ] || [ -n "${{ github.event.inputs.target_environment }}" ]; then
                SHOULD_BUILD="true"
                SHOULD_PROMOTE="false"
                SHOULD_DEPLOY="false"
                SHOULD_TEST="true"
                echo "üî® Building source image on renovations branch"
              else
                SHOULD_BUILD="false"
                SHOULD_PROMOTE="false"
                SHOULD_DEPLOY="false"
                SHOULD_TEST="false"
                echo "‚è≠Ô∏è  Skipping build: no app changes detected"
              fi
              ;;
            *)
              echo "::error::Unsupported branch: $BRANCH_NAME"
              echo "Supported branches: main, staging, renovations"
              exit 1
              ;;
          esac

          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deploy_target=$DEPLOY_TARGET" >> $GITHUB_OUTPUT
          echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "should_test=$SHOULD_TEST" >> $GITHUB_OUTPUT
          echo "should_promote=$SHOULD_PROMOTE" >> $GITHUB_OUTPUT

          echo "üìã Deployment Configuration:"
          echo "  Branch: $BRANCH_NAME"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deploy Target: $DEPLOY_TARGET"
          echo "  App Changed: $APP_CHANGED"
          echo "  Infra Changed: $INFRA_CHANGED"
          echo "  Build: $SHOULD_BUILD"
          echo "  Deploy: $SHOULD_DEPLOY"
          echo "  Test: $SHOULD_TEST"

  # Quality checks and building
  quality-and-build:
    name: Quality Checks & Build
    runs-on: ubuntu-latest
    needs: [detect-environment]
    # Always run but skip actual build/test for non-building environments
    if: always()

    # Set the environment for this job
    environment: ${{ needs.detect-environment.outputs.environment }}

    outputs:
      image_tag: ${{ github.ref_name }}-${{ github.sha }}
      image_digest: ${{ steps.build.outputs.digest }}
      test_results: ${{ steps.test.outputs.results }}
      build_success: ${{ steps.build.outcome }}

    steps:
      - name: Skip build for non-building environments
        if: needs.detect-environment.outputs.should_build != 'true'
        run: |
          echo "‚è≠Ô∏è Skipping build for ${{ needs.detect-environment.outputs.environment }} environment"
          echo "image_tag=skipped" >> $GITHUB_OUTPUT
          echo "image_digest=skipped" >> $GITHUB_OUTPUT
          echo "test_results=skipped" >> $GITHUB_OUTPUT
          echo "build_success=skipped" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: actions/checkout@v5
        with:
          fetch-depth: 0 # Full history for proper tagging

      - name: Setup Node.js
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: actions/setup-node@v5
        with:
          node-version: "22.21.0"
          cache: "npm"

      - name: Install dependencies
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm ci

      - name: Run linting
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm run lint

      - name: Run type checking
        if: needs.detect-environment.outputs.should_build == 'true' && github.event.inputs.skip_tests != 'true'
        run: npm run typecheck

      - name: Run security audit
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm audit --audit-level moderate
        continue-on-error: true

      - name: Run unit tests
        id: test
        if: needs.detect-environment.outputs.should_build == 'true' && github.event.inputs.skip_tests != 'true'
        uses: ./.github/actions/test-runner
        with:
          test_type: unit
          environment: ${{ steps.detect.outputs.environment }}
          collect_coverage: true
          fail_fast: false

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ needs.detect-environment.outputs.environment }}
          path: |
            coverage/
            test-results/
            *.xml
          retention-days: 30

      - name: Fail on test failures (unless forced)
        if: needs.detect-environment.outputs.should_build == 'true' && steps.test.outcome == 'failure' && github.event.inputs.force_deploy != 'true'
        run: |
          echo "::error::Unit tests failed and force_deploy is not enabled"
          exit 1

      - name: Log in to Container Registry
        if: needs.detect-environment.outputs.should_build == 'true'
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata
        id: meta
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/build-push-action@v5
        # Optimized for performance: scoped caching, inline cache, fast compression
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=build-${{ github.ref_name }}
          cache-to: type=gha,mode=max,scope=build-${{ github.ref_name }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          outputs: type=image,push=true,compression=zstd,compression-level=3
          provenance: false

  # Image promotion job
  promote-image:
    name: Promote Image to ${{ needs.detect-environment.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [detect-environment]
    if: needs.detect-environment.outputs.should_promote == 'true'

    outputs:
      promoted_image_tag: ${{ steps.promotion.outputs.image_tag }}

    steps:
      - name: Log in to Container Registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Determine source and target images
        id: image_info
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          case "$BRANCH_NAME" in
            "staging")
              # For staging, promote the latest renovations build
              SOURCE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:renovations"
              TARGET_TAG="staging-${{ github.sha }}"
              TARGET_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$TARGET_TAG"
              SOURCE_DESC="renovations"
              ;;
            "main")
              # For main, promote the latest staging build
              SOURCE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging"
              TARGET_TAG="main-${{ github.sha }}"
              TARGET_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:$TARGET_TAG"
              SOURCE_DESC="staging"
              ;;
            *)
              echo "::error::Unsupported branch for promotion: $BRANCH_NAME"
              exit 1
              ;;
          esac

          echo "source_image=$SOURCE_IMAGE" >> $GITHUB_OUTPUT
          echo "target_image=$TARGET_IMAGE" >> $GITHUB_OUTPUT
          echo "target_tag=$TARGET_TAG" >> $GITHUB_OUTPUT
          echo "source_desc=$SOURCE_DESC" >> $GITHUB_OUTPUT

      - name: Pull source image
        run: |
          echo "üì• Pulling source image: ${{ steps.image_info.outputs.source_image }}"
          docker pull ${{ steps.image_info.outputs.source_image }}

      - name: Verify source image exists
        run: |
          if ! docker images | grep -q "${{ env.IMAGE_NAME }}.*${{ steps.image_info.outputs.source_desc }}"; then
            echo "::error::Source image not found: ${{ steps.image_info.outputs.source_image }}"
            echo "Available images:"
            docker images | grep "${{ env.IMAGE_NAME }}"
            exit 1
          fi
          echo "‚úÖ Source image verified"

      - name: Tag image for target environment
        run: |
          echo "üè∑Ô∏è  Tagging image for ${{ needs.detect-environment.outputs.environment }}"
          docker tag ${{ steps.image_info.outputs.source_image }} ${{ steps.image_info.outputs.target_image }}
          echo "‚úÖ Image tagged"

      - name: Push promoted image
        id: push
        run: |
          echo "‚¨ÜÔ∏è  Pushing promoted image: ${{ steps.image_info.outputs.target_image }}"
          docker push ${{ steps.image_info.outputs.target_image }}
          echo "‚úÖ Image pushed successfully"

      - name: Set promoted image tag output
        id: promotion
        run: |
          echo "image_tag=${{ steps.image_info.outputs.target_tag }}" >> $GITHUB_OUTPUT
          echo "üöÄ Image promotion complete: ${{ steps.image_info.outputs.source_desc }} ‚Üí ${{ needs.detect-environment.outputs.environment }}"

  # Deployment job
  deploy:
    name: Deploy to ${{ needs.detect-environment.outputs.deploy_target }}
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build, promote-image]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.6"

      - name: Set deployment image tag
        id: image_tag
        run: |
          if [ "${{ needs.detect-environment.outputs.should_promote }}" = "true" ]; then
            echo "image_tag=${{ needs.promote-image.outputs.promoted_image_tag }}" >> $GITHUB_OUTPUT
            echo "üöÄ Using promoted image: ${{ needs.promote-image.outputs.promoted_image_tag }}"
          elif [ "${{ needs.detect-environment.outputs.should_build }}" = "true" ]; then
            echo "image_tag=${{ needs.quality-and-build.outputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "üî® Using built image: ${{ needs.quality-and-build.outputs.image_tag }}"
          else
            # For infra-only deployments, use current commit as fallback
            echo "image_tag=${{ github.ref_name }}-${{ github.sha }}" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è Using fallback image tag for infra-only deployment"
          fi

      - name: Deploy application
        uses: ./.github/actions/deploy
        id: deployment
        with:
          environment: ${{ needs.detect-environment.outputs.environment }}
          image_tag: ${{ steps.image_tag.outputs.image_tag }}
          skip_tests: ${{ github.event.inputs.skip_tests || 'false' }}
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KEY_FINGERPRINT: ${{ secrets.SSH_KEY_FINGERPRINT }}
          SPACES_ACCESS_ID: ${{ secrets.SPACES_ACCESS_ID }}
          SPACES_SECRET_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          AWS_REGION: tor1
          AWS_DEFAULT_REGION: tor1
          BREVO_API_KEY: ${{ secrets.BREVO_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          NEXT_PUBLIC_PRODUCTION_GA_ID: ${{ secrets.NEXT_PUBLIC_PRODUCTION_GA_ID }}
          ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Integration testing (staging only)
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy]
    if: needs.detect-environment.outputs.should_test == 'true' && needs.detect-environment.outputs.environment == 'staging' && github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Run integration tests
        uses: ./.github/actions/test-runner
        with:
          test_type: integration
          environment: staging
          app_url: https://staging.boximity.ca
          fail_fast: false
          timeout_minutes: 15

      - name: Run E2E tests
        uses: ./.github/actions/test-runner
        with:
          test_type: e2e
          environment: staging
          app_url: https://staging.boximity.ca
          fail_fast: false
          timeout_minutes: 20

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-results-${{ github.run_id }}
          path: |
            test-results/
            playwright-report/
          retention-days: 30

  # Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build, deploy, integration-tests]
    if: always() # Always run notifications

    steps:
      - name: Send deployment notifications
        uses: ./.github/actions/notify
        with:
          event_type: ${{ needs.deploy.result == 'success' && 'deployment-success' || 'deployment-failed' }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          workflow_run_id: ${{ github.run_id }}
          commit: ${{ github.sha }}
          triggered_by: ${{ github.actor }}
          deployment_details: |
            {
              "image_tag": "${{ needs.quality-and-build.outputs.image_tag }}",
              "image_digest": "${{ needs.quality-and-build.outputs.image_digest }}",
              "environment": "${{ needs.detect-environment.outputs.environment }}",
              "branch": "${{ github.ref_name }}",
              "build_success": "${{ needs.quality-and-build.outputs.build_success }}",
              "integration_tests": "${{ needs.integration-tests.result || 'skipped' }}",
              "timestamp": "${{ github.event.head_commit.timestamp }}"
            }
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          TEAMS_WEBHOOK: ${{ secrets.TEAMS_WEBHOOK }}
