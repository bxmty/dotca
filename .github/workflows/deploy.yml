name: Unified Deployment Pipeline

# This workflow provides a single, unified deployment pipeline that automatically
# detects the target environment based on the branch being deployed.

on:
  # Branch-based automatic deployments
  push:
    branches: [main, staging]
    paths:
      - "src/**"
      - "public/**"
      - "package.json"
      - "package-lock.json"
      - "Dockerfile"
      - "next.config.js"
      - "tsconfig.json"
      - "jest.config.js"
      - "eslint.config.mjs"
      - ".github/workflows/deploy.yml"
      - ".github/actions/deploy/action.yml"
      - "terraform/**"
      - "ansible/**"

  # Manual deployment trigger for emergency situations
  workflow_dispatch:
    inputs:
      target_environment:
        description: "Override target environment (staging|production)"
        required: false
        type: choice
        options: [staging, production]
        default: "staging"
      force_deploy:
        description: "Force deployment even if tests fail"
        required: false
        type: boolean
        default: false
      skip_tests:
        description: "Skip all tests (emergency only)"
        required: false
        type: boolean
        default: false

# Global environment variables
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1
  COMPOSE_DOCKER_CLI_BUILD: 1

# Security: Restrict permissions to minimum required
permissions:
  contents: read
  packages: write
  deployments: write
  issues: write
  pull-requests: write

jobs:
  # Check what files have changed to determine if we need to build
  check-changes:
    name: Check for App Changes
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.filter.outputs.app }}
      infra_changed: ${{ steps.filter.outputs.infra }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            app:
              - 'src/**'
              - 'public/**'
              - 'package.json'
              - 'package-lock.json'
              - 'Dockerfile'
              - 'next.config.js'
              - 'tsconfig.json'
              - 'jest.config.js'
              - 'eslint.config.mjs'
            infra:
              - 'terraform/**'
              - 'ansible/**'
              - '.github/workflows/**'
              - '.github/actions/**'

  # Environment detection and setup
  detect-environment:
    name: Environment Detection
    runs-on: ubuntu-latest
    needs: [check-changes]
    outputs:
      environment: ${{ steps.detect.outputs.environment }}
      deploy_target: ${{ steps.detect.outputs.deploy_target }}
      should_build: ${{ steps.detect.outputs.should_build }}
      should_deploy: ${{ steps.detect.outputs.should_deploy }}
      should_test: ${{ steps.detect.outputs.should_test }}
      should_promote: ${{ steps.detect.outputs.should_promote }}

    steps:
      - name: Detect environment and deployment strategy
        id: detect
        run: |
          echo "üîç Analyzing deployment context..."
          echo "GitHub Context:"
          echo "  Event: ${{ github.event_name }}"
          echo "  Ref: ${{ github.ref }}"
          echo "  Ref Name: ${{ github.ref_name }}"

          # Determine environment using explicit, reliable method
          # Priority: 1. Manual override, 2. Branch reference
          ENVIRONMENT=""
          DEPLOY_TARGET=""

          # Check for manual override first (workflow_dispatch)
          if [ -n "${{ github.event.inputs.target_environment }}" ]; then
            MANUAL_ENV="${{ github.event.inputs.target_environment }}"
            echo "üìå Manual override detected: $MANUAL_ENV"

            # Normalize and validate manual input
            case "$MANUAL_ENV" in
              "production"|"prod")
                ENVIRONMENT="production"
                DEPLOY_TARGET="production"
                ;;
              "staging"|"stg")
                ENVIRONMENT="staging"
                DEPLOY_TARGET="staging"
                ;;
              *)
                echo "::error::Invalid manual environment override: $MANUAL_ENV"
                echo "Valid options: staging, production"
                exit 1
                ;;
            esac
          else
            # Automatic detection from branch reference (most reliable)
            BRANCH_REF="${{ github.ref }}"
            BRANCH_NAME="${{ github.ref_name }}"

            echo "üîç Detecting from branch reference: $BRANCH_REF"
            echo "üîç Branch name: $BRANCH_NAME"

            # Use explicit branch reference matching for reliability
            if [[ "$BRANCH_REF" == "refs/heads/main" ]] || [[ "$BRANCH_NAME" == "main" ]]; then
              ENVIRONMENT="production"
              DEPLOY_TARGET="production"
              echo "‚úÖ Detected PRODUCTION from main branch"
            elif [[ "$BRANCH_REF" == "refs/heads/staging" ]] || [[ "$BRANCH_NAME" == "staging" ]]; then
              ENVIRONMENT="staging"
              DEPLOY_TARGET="staging"
              echo "‚úÖ Detected STAGING from staging branch"
            else
              echo "::error::Unsupported branch for automatic deployment"
              echo "Branch ref: $BRANCH_REF"
              echo "Branch name: $BRANCH_NAME"
              echo "Supported branches: main (production), staging"
              exit 1
            fi
          fi

          # Validate environment was determined
          if [ -z "$ENVIRONMENT" ] || [ -z "$DEPLOY_TARGET" ]; then
            echo "::error::Failed to determine deployment environment"
            exit 1
          fi

          # Check what files have changed
          APP_CHANGED="${{ needs.check-changes.outputs.app_changed }}"
          INFRA_CHANGED="${{ needs.check-changes.outputs.infra_changed }}"

          echo "üìä Change Analysis:"
          echo "  App files changed: $APP_CHANGED"
          echo "  Infra files changed: $INFRA_CHANGED"

          # Set deployment flags based on environment
          SHOULD_BUILD="true"
          SHOULD_PROMOTE="false"
          SHOULD_DEPLOY="true"
          SHOULD_TEST="true"

          if [ "$ENVIRONMENT" = "production" ]; then
            echo "üî® Production deployment: will build fresh image with production environment"
          elif [ "$ENVIRONMENT" = "staging" ]; then
            echo "üî® Staging deployment: will build fresh image with staging environment"
          fi

          # Output all values
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "deploy_target=$DEPLOY_TARGET" >> $GITHUB_OUTPUT
          echo "should_build=$SHOULD_BUILD" >> $GITHUB_OUTPUT
          echo "should_deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "should_test=$SHOULD_TEST" >> $GITHUB_OUTPUT
          echo "should_promote=$SHOULD_PROMOTE" >> $GITHUB_OUTPUT

          echo ""
          echo "üìã Final Deployment Configuration:"
          echo "  Environment: $ENVIRONMENT"
          echo "  Deploy Target: $DEPLOY_TARGET"
          echo "  App Changed: $APP_CHANGED"
          echo "  Infra Changed: $INFRA_CHANGED"
          echo "  Build: $SHOULD_BUILD"
          echo "  Deploy: $SHOULD_DEPLOY"
          echo "  Test: $SHOULD_TEST"
          echo ""
          echo "‚úÖ Environment detection completed successfully"

      - name: Generate deployment summary
        run: |
          cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## üöÄ Deployment Pipeline Started

          **Triggered by:** ${{ github.actor }}
          **Branch:** ${{ github.ref_name }}
          **Commit:** `${{ github.sha }}`

          ### üìä Deployment Configuration
          | Setting | Value |
          |---------|-------|
          | Environment | `${{ steps.detect.outputs.environment }}` |
          | Deploy Target | `${{ steps.detect.outputs.deploy_target }}` |
          | App Changes | ${{ needs.check-changes.outputs.app_changed == 'true' && '‚úÖ Yes' || '‚ùå No' }} |
          | Infra Changes | ${{ needs.check-changes.outputs.infra_changed == 'true' && '‚úÖ Yes' || '‚ùå No' }} |
          | Will Build | ${{ steps.detect.outputs.should_build == 'true' && '‚úÖ Yes' || '‚ùå No' }} |
          | Will Deploy | ${{ steps.detect.outputs.should_deploy == 'true' && '‚úÖ Yes' || '‚ùå No' }} |
          | Will Test | ${{ steps.detect.outputs.should_test == 'true' && '‚úÖ Yes' || '‚ùå No' }} |

          ### üîÑ Pipeline Status
          - [ ] Environment Detection ‚úÖ
          - [ ] Quality Checks & Build ${{ steps.detect.outputs.should_build == 'true' && '‚è≥' || '‚è≠Ô∏è' }}
          - [ ] Deployment ${{ steps.detect.outputs.should_deploy == 'true' && '‚è≥' || '‚è≠Ô∏è' }}
          - [ ] Integration Tests ${{ steps.detect.outputs.should_test == 'true' && '‚è≥' || '‚è≠Ô∏è' }}
          - [ ] Notifications ‚è≥

          ---
          *Workflow: `${{ github.workflow }}` | Run: #${{ github.run_number }}*
          EOF

  # Quality checks and building
  quality-and-build:
    name: Quality Checks & Build
    runs-on: ubuntu-latest
    needs: [detect-environment]
    # Always run but skip actual build/test for non-building environments
    if: always()

    # Set the environment for this job
    environment: ${{ needs.detect-environment.outputs.environment }}

    outputs:
      image_tag: ${{ github.ref_name }}-${{ github.sha }}
      image_digest: ${{ steps.build.outputs.digest }}
      test_results: ${{ steps.test.outputs.results }}
      build_success: ${{ steps.build.outcome }}

    steps:
      - name: Skip build for non-building environments
        if: needs.detect-environment.outputs.should_build != 'true'
        run: |
          echo "‚è≠Ô∏è Skipping build for ${{ needs.detect-environment.outputs.environment }} environment"
          echo "image_tag=skipped" >> $GITHUB_OUTPUT
          echo "image_digest=skipped" >> $GITHUB_OUTPUT
          echo "test_results=skipped" >> $GITHUB_OUTPUT
          echo "build_success=skipped" >> $GITHUB_OUTPUT

      - name: Checkout repository
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: actions/checkout@v6
        with:
          fetch-depth: 0 # Full history for proper tagging

      - name: Setup Node.js
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: "22.21.1"
          cache: "npm"

      - name: Install dependencies
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm ci

      - name: Run linting
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm run lint

      - name: Run type checking
        if: needs.detect-environment.outputs.should_build == 'true' && github.event.inputs.skip_tests != 'true'
        run: npm run typecheck

      - name: Run security audit
        if: needs.detect-environment.outputs.should_build == 'true'
        run: npm audit --audit-level moderate
        continue-on-error: true

      - name: Run unit tests
        id: test
        if: needs.detect-environment.outputs.should_build == 'true' && github.event.inputs.skip_tests != 'true'
        uses: ./.github/actions/test-runner
        with:
          test_type: unit
          environment: ${{ needs.detect-environment.outputs.environment }}
          collect_coverage: true
          fail_fast: false

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: test-results-${{ needs.detect-environment.outputs.environment }}
          path: |
            coverage/
            test-results/
            *.xml
          retention-days: 30

      - name: Fail on test failures (unless forced)
        if: needs.detect-environment.outputs.should_build == 'true' && steps.test.outcome == 'failure' && github.event.inputs.force_deploy != 'true'
        run: |
          echo "::error::Unit tests failed and force_deploy is not enabled"
          exit 1

      - name: Log in to Container Registry
        if: needs.detect-environment.outputs.should_build == 'true'
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata
        id: meta
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set up Docker Buildx
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        id: build
        if: needs.detect-environment.outputs.should_build == 'true'
        uses: docker/build-push-action@v6
        # Optimized for performance: scoped caching, inline cache, fast compression
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=build-${{ github.ref_name }}
          cache-to: type=gha,mode=max,scope=build-${{ github.ref_name }}
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            NODE_ENV=production
            NEXT_PUBLIC_ENVIRONMENT=${{ needs.detect-environment.outputs.environment }}
            NEXT_PUBLIC_API_URL=${{ needs.detect-environment.outputs.environment == 'production' && 'https://boximity.ca/api' || 'https://staging.boximity.ca/api' }}
            NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
            NEXT_PUBLIC_STAGING_GA_ID=${{ secrets.NEXT_PUBLIC_STAGING_GA_ID }}
            NEXT_PUBLIC_PRODUCTION_GA_ID=${{ secrets.NEXT_PUBLIC_PRODUCTION_GA_ID }}
            STRIPE_SECRET_KEY=${{ secrets.STRIPE_SECRET_KEY }}
          outputs: type=image,push=true,compression=zstd,compression-level=3
          provenance: false

      - name: Update build summary
        if: always()
        run: |
          if [ "${{ needs.detect-environment.outputs.should_build }}" = "true" ]; then
            BUILD_STATUS="${{ steps.build.outcome == 'success' && '‚úÖ Success' || steps.build.outcome == 'failure' && '‚ùå Failed' || '‚è≥ Running' }}"
            TEST_STATUS="${{ steps.test.outcome == 'success' && '‚úÖ Passed' || steps.test.outcome == 'failure' && '‚ùå Failed' || steps.test.outcome == 'skipped' && '‚è≠Ô∏è Skipped' || '‚è≥ Running' }}"
          else
            BUILD_STATUS="‚è≠Ô∏è Skipped"
            TEST_STATUS="‚è≠Ô∏è Skipped"
          fi

          cat << EOF >> \$GITHUB_STEP_SUMMARY

          ### üî® Build & Quality Status
          | Component | Status |
          |-----------|--------|
          | Code Linting | ${{ steps.build.outcome == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |
          | Type Checking | ${{ steps.build.outcome == 'success' && '‚úÖ Passed' || '‚ùå Failed' }} |
          | Security Audit | ${{ steps.build.outcome == 'success' && '‚úÖ Passed' || '‚ö†Ô∏è Warnings' }} |
          | Unit Tests | \$TEST_STATUS |
          | Docker Build | \$BUILD_STATUS |

          EOF

          if [ "${{ steps.build.outcome }}" = "success" ] && [ "${{ needs.detect-environment.outputs.should_build }}" = "true" ]; then
            echo "**Image Tag:** \`${{ steps.meta.outputs.tags }}\`" >> \$GITHUB_STEP_SUMMARY
            echo "**Image Digest:** \`${{ steps.build.outputs.digest }}\`" >> \$GITHUB_STEP_SUMMARY
            echo "**Environment:** \`${{ needs.detect-environment.outputs.environment }}\`" >> \$GITHUB_STEP_SUMMARY
          fi

  # Deployment job
  deploy:
    name: Deploy to ${{ needs.detect-environment.outputs.deploy_target }}
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build]
    if: needs.detect-environment.outputs.should_deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.environment }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.14.3"

      - name: Set deployment image tag
        id: image_tag
        run: |
          if [ "${{ needs.detect-environment.outputs.should_build }}" = "true" ]; then
            echo "image_tag=${{ needs.quality-and-build.outputs.image_tag }}" >> $GITHUB_OUTPUT
            echo "üî® Using freshly built image: ${{ needs.quality-and-build.outputs.image_tag }}"
          else
            echo "::error::No image available for deployment"
            exit 1
          fi

      - name: Deploy application
        uses: ./.github/actions/deploy
        id: deployment
        with:
          environment: ${{ needs.detect-environment.outputs.environment }}
          image_tag: ${{ steps.image_tag.outputs.image_tag }}
          skip_tests: ${{ github.event.inputs.skip_tests || 'false' }}
        env:
          DO_TOKEN: ${{ secrets.DO_TOKEN }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_KEY_FINGERPRINT: ${{ secrets.SSH_KEY_FINGERPRINT }}
          SPACES_ACCESS_ID: ${{ secrets.SPACES_ACCESS_ID }}
          SPACES_SECRET_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_KEY }}
          AWS_REGION: tor1
          AWS_DEFAULT_REGION: tor1
          BREVO_API_KEY: ${{ secrets.BREVO_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          NEXT_PUBLIC_STAGING_GA_ID: ${{ secrets.NEXT_PUBLIC_STAGING_GA_ID }}
          NEXT_PUBLIC_PRODUCTION_GA_ID: ${{ secrets.NEXT_PUBLIC_PRODUCTION_GA_ID }}
          ANSIBLE_VAULT_PASSWORD: ${{ secrets.ANSIBLE_VAULT_PASSWORD }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update deployment summary
        if: always()
        run: |
          DEPLOY_STATUS="${{ job.status == 'success' && '‚úÖ Success' || job.status == 'failure' && '‚ùå Failed' || '‚è≥ Running' }}"

          cat << EOF >> \$GITHUB_STEP_SUMMARY

          ### üöÄ Deployment Status
          | Component | Details |
          |-----------|---------|
          | Target Environment | \`${{ needs.detect-environment.outputs.environment }}\` |
          | Deploy Target | \`${{ needs.detect-environment.outputs.deploy_target }}\` |
          | Image Tag Used | \`${{ steps.image_tag.outputs.image_tag }}\` |
          | Image Built For | \`${{ needs.detect-environment.outputs.environment }}\` |
          | Deployment Status | \$DEPLOY_STATUS |

          EOF

          if [ "${{ job.status }}" = "success" ]; then
            echo "**üåê Application URL:** https://${{ needs.detect-environment.outputs.environment == 'production' && 'boximity.ca' || needs.detect-environment.outputs.environment == 'staging' && 'staging.boximity.ca' || 'dev.boximity.ca' }}" >> \$GITHUB_STEP_SUMMARY
          fi

  # Integration testing
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [detect-environment, deploy]
    if: needs.detect-environment.outputs.should_test == 'true' && github.event.inputs.skip_tests != 'true'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Run integration tests
        uses: ./.github/actions/test-runner
        with:
          test_type: integration
          environment: ${{ needs.detect-environment.outputs.environment }}
          app_url: ${{ needs.detect-environment.outputs.environment == 'production' && 'https://boximity.ca' || 'https://staging.boximity.ca' }}
          fail_fast: false
          timeout_minutes: 15

      - name: Run E2E tests
        uses: ./.github/actions/test-runner
        with:
          test_type: e2e
          environment: ${{ needs.detect-environment.outputs.environment }}
          app_url: ${{ needs.detect-environment.outputs.environment == 'production' && 'https://boximity.ca' || 'https://staging.boximity.ca' }}
          fail_fast: false
          timeout_minutes: 20

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: e2e-results-${{ github.run_id }}
          path: |
            test-results/
            playwright-report/
          retention-days: 30

      - name: Update testing summary
        if: always()
        run: |
          TEST_STATUS="${{ job.status == 'success' && '‚úÖ Passed' || job.status == 'failure' && '‚ùå Failed' || '‚è≥ Running' }}"
          DETECTED_ENV="${{ needs.detect-environment.outputs.environment }}"

          # Determine test URL based on detected environment
          if [ "$DETECTED_ENV" = "production" ]; then
            TEST_URL="https://boximity.ca"
          else
            TEST_URL="https://staging.boximity.ca"
          fi

          cat << EOF >> \$GITHUB_STEP_SUMMARY

          ### üß™ Integration Testing Status
          | Test Type | Status |
          |-----------|--------|
          | Integration Tests | \$TEST_STATUS |
          | E2E Tests | \$TEST_STATUS |
          | Test Environment | \`$DETECTED_ENV\` |
          | Test URL | \$TEST_URL |

          EOF

  # Notifications
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [detect-environment, quality-and-build, deploy, integration-tests]
    if: always() # Always run notifications

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Send GitHub deployment notifications
        uses: ./.github/actions/notify
        with:
          event_type: ${{ needs.deploy.result == 'success' && 'deployment-success' || 'deployment-failed' }}
          environment: ${{ needs.detect-environment.outputs.environment }}
          workflow_run_id: ${{ github.run_id }}
          commit: ${{ github.sha }}
          triggered_by: ${{ github.actor }}
          deployment_details: |
            {
              "image_tag": "${{ needs.quality-and-build.outputs.image_tag }}",
              "image_digest": "${{ needs.quality-and-build.outputs.image_digest }}",
              "environment": "${{ needs.detect-environment.outputs.environment }}",
              "branch": "${{ github.ref_name }}",
              "build_success": "${{ needs.quality-and-build.outputs.build_success }}",
              "integration_tests": "${{ needs.integration-tests.result || 'skipped' }}",
              "timestamp": "${{ github.event.head_commit.timestamp }}"
            }

      - name: Generate final workflow summary
        if: always()
        run: |
          OVERALL_STATUS="${{ needs.deploy.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}"
          DURATION="<!-- Workflow completed at ${{ github.event.head_commit.timestamp || 'unknown time' }} -->"

          cat << EOF >> \$GITHUB_STEP_SUMMARY

          ## üìã Final Deployment Summary

          **Overall Status:** \$OVERALL_STATUS
          **Completed:** \`${{ github.event.head_commit.timestamp }}\`

          ### üîÑ Pipeline Results
          | Stage | Result |
          |-------|--------|
          | Environment Detection | ‚úÖ Completed |
          | Quality Checks & Build | ${{ needs.quality-and-build.result == 'success' && '‚úÖ Success' || needs.quality-and-build.result == 'failure' && '‚ùå Failed' || needs.quality-and-build.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚è≥ Running' }} |
          | Deployment | ${{ needs.deploy.result == 'success' && '‚úÖ Success' || needs.deploy.result == 'failure' && '‚ùå Failed' || needs.deploy.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚è≥ Running' }} |
          | Integration Tests | ${{ needs.integration-tests.result == 'success' && '‚úÖ Passed' || needs.integration-tests.result == 'failure' && '‚ùå Failed' || needs.integration-tests.result == 'skipped' && '‚è≠Ô∏è Skipped' || '‚è≥ Running' }} |
          | Notifications | ${{ job.status == 'success' && '‚úÖ Sent' || '‚ùå Failed' }} |

          ### üìä Key Information
          - **Environment:** \`${{ needs.detect-environment.outputs.environment }}\`
          - **Image Tag:** \`${{ needs.quality-and-build.outputs.image_tag || 'N/A' }}\`
          - **Commit:** \`${{ github.sha }}\`
          - **Triggered by:** ${{ github.actor }}

          EOF

          if [ "${{ needs.deploy.result }}" = "success" ]; then
            echo "**üåê Live Application:** https://${{ needs.detect-environment.outputs.environment == 'production' && 'boximity.ca' || needs.detect-environment.outputs.environment == 'staging' && 'staging.boximity.ca' || 'dev.boximity.ca' }}" >> \$GITHUB_STEP_SUMMARY
          fi

          echo "---" >> \$GITHUB_STEP_SUMMARY
          echo "*Workflow completed* \$DURATION" >> \$GITHUB_STEP_SUMMARY
