name: Production Pipeline

on:
  # Manual trigger for production deployment using promoted images
  workflow_dispatch:
    inputs:
      promoted_image_tag:
        description: 'Promoted image tag to deploy (e.g., main, main-abc123)'
        required: true
        default: 'main'
        type: string
      deployment_reason:
        description: 'Reason for production deployment'
        required: false
        default: 'Manual production deployment'
        type: string
      skip_tests:
        description: 'Skip Selenium tests (use for emergency deployments)'
        required: false
        default: false
        type: boolean
  
  # Automatic trigger after successful image promotion
  workflow_call:
    inputs:
      promoted_image_tag:
        description: 'Promoted image tag to deploy'
        required: true
        type: string
      deployment_reason:
        description: 'Reason for deployment'
        required: false
        type: string
        default: 'Automatic deployment after image promotion'
    secrets:
      DO_TOKEN:
        required: true
      SSH_PRIVATE_KEY:
        required: true
      SSH_KEY_FINGERPRINT:
        required: true
      SPACES_ACCESS_ID:
        required: true
      SPACES_SECRET_KEY:
        required: true
      BREVO_API_KEY:
        required: true
      STRIPE_SECRET_KEY:
        required: true
      NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:
        required: true
      NEXT_PUBLIC_PRODUCTION_GA_ID:
        required: true
      GITHUB_TOKEN:
        required: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  # Use promoted image tag from input, fallback to 'main'
  PROMOTED_IMAGE_TAG: ${{ inputs.promoted_image_tag || github.event.inputs.promoted_image_tag || 'main' }}
  DEPLOYMENT_REASON: ${{ inputs.deployment_reason || github.event.inputs.deployment_reason || 'Production deployment' }}

jobs:
  verify-promoted-image:
    name: Verify Promoted Image
    runs-on: ubuntu-latest
    outputs:
      image_verified: ${{ steps.verification.outputs.verified }}
      full_image_name: ${{ steps.verification.outputs.full_image_name }}
      image_digest: ${{ steps.verification.outputs.image_digest }}
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Verify promoted image exists and is accessible
        id: verification
        run: |
          FULL_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.PROMOTED_IMAGE_TAG }}"
          
          echo "🔍 Verifying promoted image: $FULL_IMAGE_NAME"
          echo "📋 Deployment reason: ${{ env.DEPLOYMENT_REASON }}"
          
          # Pull and verify the promoted image
          if docker pull "$FULL_IMAGE_NAME"; then
            echo "✅ Successfully pulled promoted image"
            
            # Get image details
            IMAGE_DIGEST=$(docker images --digests "$FULL_IMAGE_NAME" --format "{{.Digest}}" | head -1)
            IMAGE_SIZE=$(docker images --format "{{.Size}}" "$FULL_IMAGE_NAME" | head -1)
            IMAGE_CREATED=$(docker images --format "{{.CreatedAt}}" "$FULL_IMAGE_NAME" | head -1)
            
            echo "📊 Image Details:"
            echo "- Digest: $IMAGE_DIGEST"
            echo "- Size: $IMAGE_SIZE"
            echo "- Created: $IMAGE_CREATED"
            
            # Set outputs
            echo "verified=true" >> $GITHUB_OUTPUT
            echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
            echo "image_digest=$IMAGE_DIGEST" >> $GITHUB_OUTPUT
            
            echo "✅ Promoted image verification successful"
          else
            echo "❌ Failed to pull promoted image: $FULL_IMAGE_NAME"
            echo "This usually means:"
            echo "1. The image tag doesn't exist in the registry"
            echo "2. The image promotion hasn't completed yet"
            echo "3. There are authentication issues"
            echo ""
            echo "Please verify the image exists by checking:"
            echo "https://github.com/${{ github.repository }}/pkgs/container/dotca"
            exit 1
          fi
    
  setup-infra:
    name: Setup Infrastructure
    runs-on: ubuntu-latest
    outputs:
      droplet_ip: ${{ steps.resource_check.outputs.ip || steps.get_ip.outputs.ip }}
      resources_exist: ${{ steps.resource_check.outputs.resources_exist }}
      terraform_changes: ${{ steps.check_terraform_changes.outputs.has_changes }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7
          
      - name: Setup DigitalOcean CLI
        run: |
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.94.0/doctl-1.94.0-linux-amd64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin/
          doctl auth init -t ${{ secrets.DO_TOKEN }}
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
      - name: Initialize Terraform
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="access_key=${{ secrets.SPACES_ACCESS_ID }}" \
            -backend-config="secret_key=${{ secrets.SPACES_SECRET_KEY }}" \
            -backend-config="key=dotca/terraform-production.tfstate"
          
      - name: Check if project exists
        id: check_project
        run: |
            # Check if the project exists in Digital Ocean
            PROJECT_EXISTS=$(doctl projects list --format Name --no-header | grep -F "dotca-nextjs" || echo "")
            
            if [ -n "$PROJECT_EXISTS" ]; then
              echo "PROJECT_EXISTS=true" >> $GITHUB_ENV
              echo "Project 'dotca-nextjs' already exists"
            else
              echo "PROJECT_EXISTS=false" >> $GITHUB_ENV
              echo "Project 'dotca-nextjs' does not exist"
            fi
        
      - name: Check if resources exist
        working-directory: ./terraform
        id: resource_check
        run: |
          # Set terraform variables
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="main"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          
          # Try to get current state - handle failure gracefully
          terraform refresh || echo "Terraform refresh failed, likely because resources don't exist yet"
          
          # Check if resources exist by trying to get the IP
          DROPLET_IP=$(terraform output droplet_ip 2>/dev/null | tr -d '"' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' || echo "")
          
          if [ -n "$DROPLET_IP" ]; then
            echo "RESOURCES_EXIST=true" >> $GITHUB_ENV
            echo "resources_exist=true" >> $GITHUB_OUTPUT
            echo "DROPLET_IP=$DROPLET_IP" >> $GITHUB_ENV
            echo "ip=$DROPLET_IP" >> $GITHUB_OUTPUT
            echo "Resources already exist, using IP: $DROPLET_IP"
          else
            echo "RESOURCES_EXIST=false" >> $GITHUB_ENV
            echo "resources_exist=false" >> $GITHUB_OUTPUT
            echo "Resources need to be created or updated"
          fi
        continue-on-error: true
      
      # New step to check for Terraform changes in existing resources
      - name: Check for Terraform changes
        id: check_terraform_changes
        working-directory: ./terraform
        if: env.RESOURCES_EXIST == 'true'
        run: |
          # Set terraform variables as environment variables
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="production"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          
          # Create a plan and check if there are any changes
          terraform plan -detailed-exitcode -out=tfplan > plan_output.txt 2>&1
          PLAN_EXIT_CODE=$?
          
          # Terraform plan exit codes:
          # 0 = No changes
          # 1 = Error
          # 2 = Changes present
          
          if [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "HAS_CHANGES=true" >> $GITHUB_ENV
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changes detected in Terraform plan"
          elif [ $PLAN_EXIT_CODE -eq 0 ]; then
            echo "HAS_CHANGES=false" >> $GITHUB_ENV
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No changes detected in Terraform plan"
          else
            echo "::error::Terraform plan failed with exit code $PLAN_EXIT_CODE"
            cat plan_output.txt
            exit 1
          fi
        continue-on-error: true
      
      # New step to apply Terraform changes if they exist
      - name: Apply Terraform changes
        if: env.RESOURCES_EXIST == 'true' && env.HAS_CHANGES == 'true'
        working-directory: ./terraform
        run: |
          # Set terraform variables as environment variables
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="production"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          
          # Apply the changes
          echo "Applying changes to existing infrastructure..."
          terraform apply -auto-approve tfplan
          
          # Update the droplet IP in case it changed
          UPDATED_IP=$(terraform output droplet_ip | tr -d '"' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+')
          if [ -n "$UPDATED_IP" ]; then
            echo "DROPLET_IP=$UPDATED_IP" >> $GITHUB_ENV
            echo "Updated droplet IP: $UPDATED_IP"
          fi

      - name: Terraform Plan
        if: env.RESOURCES_EXIST != 'true'
        working-directory: ./terraform
        run: |
          # Set terraform variables as environment variables
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="production"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          
          # Create plan
          terraform plan -out=tfplan
        
      - name: Terraform Apply
        if: env.RESOURCES_EXIST != 'true'
        working-directory: ./terraform
        run: |
          # Set terraform variables as environment variables
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="production"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          
          # Apply the plan
          terraform apply -auto-approve tfplan
        
      - name: Capture Droplet IP
        if: env.RESOURCES_EXIST != 'true'
        working-directory: ./terraform
        id: get_ip
        run: |
          # Wait a bit for Terraform state to settle
          echo "Waiting for DigitalOcean resources to be fully provisioned..."
          sleep 30
          
          # Force a refresh to ensure state is current
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="production"
          export TF_VAR_use_existing_project="${{ env.PROJECT_EXISTS }}"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="production"
          terraform refresh
          
          # Try multiple methods to get the IP address
          echo "Attempting to get droplet IP address..."
          
          # Method 1: Direct output to a file first to avoid pipe issues
          terraform output > terraform_output.txt
          cat terraform_output.txt
          
          # Extract IP using grep directly on the file
          DROPLET_IP=$(grep -oE 'droplet_ip\s*=\s*"([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)"' terraform_output.txt | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' || echo "")
          
          # If that didn't work, try a simpler approach
          if [ -z "$DROPLET_IP" ] || ! [[ $DROPLET_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Trying alternative method..."
            DROPLET_IP=$(cat terraform_output.txt | grep droplet_ip | awk -F '"' '{print $2}' || echo "")
          fi
          
          # Final validation and output
          if [[ $DROPLET_IP =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Successfully extracted IP: $DROPLET_IP"
            echo "DROPLET_IP=$DROPLET_IP" >> $GITHUB_ENV
            echo "ip=$DROPLET_IP" >> $GITHUB_OUTPUT
          else
            echo "::error::Failed to extract valid IP address from Terraform output"
            echo "Raw terraform output was:"
            cat terraform_output.txt
            exit 1
          fi

  deploy-app:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [verify-promoted-image, setup-infra]
    if: ${{ needs.verify-promoted-image.outputs.image_verified == 'true' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Install Ansible
        run: |
          sudo apt update
          sudo apt install -y ansible
      
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
      
      - name: Add host key to known hosts
        env:
          DROPLET_IP: ${{ needs.setup-infra.outputs.droplet_ip }}
          RESOURCES_EXIST: ${{ needs.setup-infra.outputs.resources_exist }}
          TERRAFORM_CHANGES: ${{ needs.setup-infra.outputs.terraform_changes }}
        run: |
          # Fail if we don't have an IP address
          if [ -z "$DROPLET_IP" ]; then
            echo "::error::Could not determine server IP address - infrastructure setup failed"
            exit 1
          fi
          
          echo "Connecting to IP: $DROPLET_IP"
          
          # Wait longer for new or updated resources to be fully ready
          if [ "$RESOURCES_EXIST" != "true" ] || [ "$TERRAFORM_CHANGES" == "true" ]; then
            echo "Waiting for droplet to be fully ready..."
            # Try to ping the droplet until it's accessible
            TIMEOUT=300
            INTERVAL=10
            ELAPSED=0
            while [ $ELAPSED -lt $TIMEOUT ]; do
              echo "Attempting to ping $DROPLET_IP... (${ELAPSED}s elapsed)"
              if ping -c 1 -W 5 $DROPLET_IP &> /dev/null; then
                echo "Successfully reached droplet at $DROPLET_IP"
                break
              fi
              sleep $INTERVAL
              ELAPSED=$((ELAPSED + INTERVAL))
            done
            
            if [ $ELAPSED -ge $TIMEOUT ]; then
              echo "::warning::Droplet at $DROPLET_IP is not responding to ping after ${TIMEOUT}s"
              # Continue anyway, since SSH might still work
            fi
            
            # Additional wait time for services to start
            echo "Waiting additional time for services to start..."
            sleep 30
          fi
          
          # Add host key to known_hosts
          echo "Adding host key for $DROPLET_IP to known_hosts..."
          for i in {1..5}; do
            if ssh-keyscan -H $DROPLET_IP >> ~/.ssh/known_hosts 2>/dev/null; then
              echo "Successfully added host key on attempt $i"
              break
            else
              echo "Attempt $i to add host key failed, retrying in 10 seconds..."
              sleep 10
            fi
            
            if [ $i -eq 5 ]; then
              echo "::warning::Failed to add host key after 5 attempts, continuing anyway..."
            fi
          done
      
      - name: Deploy using Ansible
        env:
          GIT_REPO_URL: "${{ github.server_url }}/${{ github.repository }}.git"
          SSH_KEY_PATH: "~/.ssh/id_rsa"
          GITHUB_ACTIONS: "true"
          DROPLET_IP: ${{ needs.setup-infra.outputs.droplet_ip }}
          BREVO_API_KEY: ${{ secrets.BREVO_API_KEY }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_SECRET_KEY }}
          STRIPE_PUBLISHABLE_KEY: ${{ secrets.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY }}
          GA_PRODUCTION_ID: ${{ secrets.NEXT_PUBLIC_PRODUCTION_GA_ID }}
          # Use promoted image instead of building from scratch
          DOCKER_IMAGE: ${{ needs.verify-promoted-image.outputs.full_image_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_USERNAME: ${{ github.actor }}
        run: |
          # Verify IP address is set in the environment
          if [ -z "$DROPLET_IP" ]; then
            echo "::error::DROPLET_IP environment variable is not set"
            exit 1
          fi
          
          echo "🚀 Production Deployment using Image Promotion"
          echo "=============================================="
          echo "Droplet IP: $DROPLET_IP"
          echo "Promoted Image: $DOCKER_IMAGE"
          echo "Image Digest: ${{ needs.verify-promoted-image.outputs.image_digest }}"
          echo "Deployment Reason: ${{ env.DEPLOYMENT_REASON }}"
          echo "=============================================="
          
          # Set up ansible inventory dynamically
          echo "[digitalocean]" > inventory.ini
          echo "$DROPLET_IP ansible_user=root ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=30'" >> inventory.ini
          cat inventory.ini
          
          # Ensure script is executable
          chmod +x ./deploy.sh
          
          # Test SSH connection
          echo "Testing SSH connection to $DROPLET_IP..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i ~/.ssh/id_rsa root@$DROPLET_IP "echo SSH connection successful" || echo "SSH connection test failed, but continuing deployment anyway"
          
          # Run the deployment with retry logic
          echo "Starting deployment..."
          DEPLOY_SUCCESS=false
          for i in {1..3}; do
            echo "Deployment attempt $i..."
            if ANSIBLE_HOST_KEY_CHECKING=False ./deploy.sh production; then
              echo "Deployment successful on attempt $i"
              DEPLOY_SUCCESS=true
              break
            else
              echo "Deployment attempt $i failed. Waiting before retry..."
              sleep 30
            fi
          done
          
          if [ "$DEPLOY_SUCCESS" != "true" ]; then
            echo "::error::All deployment attempts failed"
            echo "ansible_failed=true" >> $GITHUB_OUTPUT
            exit 1  # This ensures the job fails if all deployment attempts fail
          fi
  
  deployment-verification:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: [verify-promoted-image, setup-infra, deploy-app]
    
    steps:
      - name: Production Deployment Status
        env:
          DROPLET_IP: ${{ needs.setup-infra.outputs.droplet_ip }}
        run: |
          echo "✅ Production deployment completed using promoted image!"
          echo "🌐 Access it at http://$DROPLET_IP/"
          echo ""
          echo "📊 Deployment Summary:"
          echo "- Promoted Image: ${{ needs.verify-promoted-image.outputs.full_image_name }}"
          echo "- Image Digest: ${{ needs.verify-promoted-image.outputs.image_digest }}"
          echo "- Deployment Reason: ${{ env.DEPLOYMENT_REASON }}"
          echo "- Workflow: Image Promotion → Production Deployment"
          echo ""
          
          # Health check
          echo "🔍 Checking if application is responding..."
          if curl -s --head --request GET http://$DROPLET_IP/ | grep "200 OK" > /dev/null; then
            echo "✅ Application is up and running!"
            echo "🎉 Production deployment successful!"
          else
            echo "⚠️ Application might not be fully available yet"
            echo "📝 Please check application logs if issues persist"
          fi

  selenium-tests:
    name: Run Selenium Tests
    runs-on: ubuntu-latest
    needs: [deployment-verification]
    if: ${{ !inputs.skip_tests && !github.event.inputs.skip_tests }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Install Chrome
        run: |
          wget -q -O - https://dl-ssl.google.com/linux/linux_signing_key.pub | sudo apt-key add -
          echo "deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main" | sudo tee /etc/apt/sources.list.d/google.list
          sudo apt-get update
          sudo apt-get install -y google-chrome-stable
      
      - name: Run Selenium tests
        env:
          APP_URL: http://${{ needs.setup-infra.outputs.droplet_ip }}
        run: npm run test:e2e
        continue-on-error: true

  deployment-summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [verify-promoted-image, setup-infra, deploy-app, deployment-verification, selenium-tests]
    if: always()
    steps:
      - name: Generate deployment summary
        run: |
          echo "## 🚀 Production Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Determine overall status
          if [ "${{ needs.deploy-app.result }}" = "success" ] && [ "${{ needs.deployment-verification.result }}" = "success" ]; then
            echo "**Overall Status:** 🟢 SUCCESS" >> $GITHUB_STEP_SUMMARY
            STATUS="SUCCESS"
          else
            echo "**Overall Status:** 🔴 FAILED" >> $GITHUB_STEP_SUMMARY
            STATUS="FAILED"
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Details:**" >> $GITHUB_STEP_SUMMARY
          echo "- Promoted Image: ${{ needs.verify-promoted-image.outputs.full_image_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- Image Digest: ${{ needs.verify-promoted-image.outputs.image_digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment Reason: ${{ env.DEPLOYMENT_REASON }}" >> $GITHUB_STEP_SUMMARY
          echo "- Production URL: http://${{ needs.setup-infra.outputs.droplet_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "**Job Results:**" >> $GITHUB_STEP_SUMMARY
          echo "- Image Verification: ${{ needs.verify-promoted-image.result == 'success' && '✅' || '❌' }} ${{ needs.verify-promoted-image.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure Setup: ${{ needs.setup-infra.result == 'success' && '✅' || '❌' }} ${{ needs.setup-infra.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Application Deployment: ${{ needs.deploy-app.result == 'success' && '✅' || '❌' }} ${{ needs.deploy-app.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Deployment Verification: ${{ needs.deployment-verification.result == 'success' && '✅' || '❌' }} ${{ needs.deployment-verification.result }}" >> $GITHUB_STEP_SUMMARY
          
          # Handle selenium tests (might be skipped)
          if [ "${{ inputs.skip_tests }}" = "true" ] || [ "${{ github.event.inputs.skip_tests }}" = "true" ]; then
            echo "- Selenium Tests: ⏭️ SKIPPED (Emergency deployment)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- Selenium Tests: ${{ needs.selenium-tests.result == 'success' && '✅' || (needs.selenium-tests.result == 'failure' && '⚠️') || '❌' }} ${{ needs.selenium-tests.result }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          if [ "$STATUS" = "SUCCESS" ]; then
            echo "1. ✅ Production deployment completed successfully" >> $GITHUB_STEP_SUMMARY
            echo "2. 🔍 Monitor application performance and logs" >> $GITHUB_STEP_SUMMARY
            echo "3. 📋 Verify all features are working as expected" >> $GITHUB_STEP_SUMMARY
            echo "4. 🎉 Deployment process complete!" >> $GITHUB_STEP_SUMMARY
          else
            echo "1. ❌ Production deployment failed" >> $GITHUB_STEP_SUMMARY
            echo "2. 🔍 Review workflow logs for error details" >> $GITHUB_STEP_SUMMARY
            echo "3. 🛠️ Fix any identified issues" >> $GITHUB_STEP_SUMMARY
            echo "4. 🔄 Consider rollback if necessary" >> $GITHUB_STEP_SUMMARY
          fi