name: Single Developer CI/CD Pipeline

on:
  push:
    branches: [renovations, staging, main]
    paths:
      - 'src/**'
      - 'public/**'
      - 'package.json'
      - 'package-lock.json'
      - 'Dockerfile'
      - 'next.config.js'
      - 'tsconfig.json'
      - '.github/workflows/single-developer-cicd.yml'
  pull_request:
    branches: [renovations, staging, main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and test on all branches
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      test_passed: ${{ steps.test.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '22.21.0'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run tests
        id: test
        run: |
          if npm test; then
            echo "passed=true" >> $GITHUB_OUTPUT
            echo "âœ… Tests passed"
          else
            echo "passed=false" >> $GITHUB_OUTPUT
            echo "âŒ Tests failed"
            exit 1
          fi

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
            NEXT_PUBLIC_ENVIRONMENT=${{ github.ref_name }}
            NEXT_PUBLIC_COMMIT_HASH=${{ github.sha }}

  # Deploy to staging when pushing to staging branch
  deploy-staging:
    name: Deploy to Staging
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' && needs.build-and-test.outputs.test_passed == 'true'
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.7

      - name: Setup DigitalOcean CLI
        run: |
          curl -sL https://github.com/digitalocean/doctl/releases/download/v1.94.0/doctl-1.94.0-linux-amd64.tar.gz | tar -xzv
          sudo mv doctl /usr/local/bin/
          doctl auth init -t ${{ secrets.DO_TOKEN }}

      - name: Setup infrastructure
        working-directory: ./terraform
        run: |
          terraform init \
            -backend-config="access_key=${{ secrets.SPACES_ACCESS_ID }}" \
            -backend-config="secret_key=${{ secrets.SPACES_SECRET_KEY }}" \
            -backend-config="key=dotca/terraform-staging.tfstate"
          export TF_VAR_do_token="${{ secrets.DO_TOKEN }}"
          export TF_VAR_ssh_key_fingerprint="${{ secrets.SSH_KEY_FINGERPRINT }}"
          export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
          export TF_VAR_git_branch="staging"
          export TF_VAR_use_existing_project="true"
          export TF_VAR_use_existing_firewall="false"
          export TF_VAR_environment="staging"

          terraform plan -out=tfplan
          terraform apply -auto-approve tfplan

      - name: Get droplet IP
        working-directory: ./terraform
        id: ip
        run: |
          DROPLET_IP=$(terraform output -raw droplet_ip)
          echo "ip=$DROPLET_IP" >> $GITHUB_OUTPUT

      - name: Deploy application
        run: |
          sudo apt update && sudo apt install -y ansible
          ansible-galaxy install -r ansible/requirements.yml

          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          printf '%s\n' "${{ secrets.ANSIBLE_VAULT_PASSWORD }}" > ~/.ansible_vault_pass
          chmod 600 ~/.ansible_vault_pass

          DROPLET_IP="${{ steps.ip.outputs.ip }}"

          cat > ansible/inventory.ini << EOF
          [staging]
          staging-server ansible_host=$DROPLET_IP ansible_user=root ansible_ssh_private_key_file=~/.ssh/id_rsa ansible_ssh_common_args='-o StrictHostKeyChecking=no'
          EOF

          cd ansible
          ansible-playbook -i inventory.ini staging-deploy.yml --vault-password-file ~/.ansible_vault_pass \
            -e "DOCKER_IMAGE=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging"

      - name: Run Playwright tests
        run: |
          npx playwright install --with-deps chromium
          APP_URL="http://${{ steps.ip.outputs.ip }}" npm run test:e2e

      - name: Notify staging deployment
        run: |
          echo "## ðŸŽ‰ Staging Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: http://${{ steps.ip.outputs.ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: âœ… Passed" >> $GITHUB_STEP_SUMMARY

  # Manual promotion to production
  promote-to-production:
    name: Promote to Production
    needs: build-and-test
    runs-on: ubuntu-latest
    if: (github.ref == 'refs/heads/main' || github.event.inputs.environment == 'production') && needs.build-and-test.outputs.test_passed == 'true'
    environment: production-promotion

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull staging image
        run: docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging

      - name: Tag for production
        run: |
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main
          docker tag ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:staging ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Push production images
        run: |
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main
          docker push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Trigger production deployment
        uses: ./.github/workflows/prod-deploy.yml
        with:
          promoted_image_tag: 'main'
          deployment_reason: 'Automatic deployment after merge to main branch'

  # Handle PRs to renovations branch
  pr-checks:
    name: PR Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.base_ref == 'renovations'

    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Setup Node.js
        uses: actions/setup-node@v5
        with:
          node-version: '22.21.0'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting and tests
        run: |
          npm run lint
          npm test

      - name: Build check
        run: npm run build
