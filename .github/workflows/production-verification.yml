name: Production Verification

# Standalone production verification workflow
# Can be used to verify production deployment health at any time

on:
  workflow_dispatch:
    inputs:
      verification_type:
        description: 'Type of verification to perform'
        required: true
        type: choice
        options:
          - 'comprehensive'
          - 'health-only'
          - 'performance-only'
          - 'security-only'
        default: 'comprehensive'
      target_url:
        description: 'Production URL to verify (leave empty to auto-detect)'
        required: false
        type: string
        default: ''
      notification_level:
        description: 'Notification level for issues'
        required: false
        type: choice
        options:
          - 'none'
          - 'warnings'
          - 'errors-only'
          - 'all'
        default: 'warnings'

  workflow_call:
    inputs:
      verification_type:
        description: 'Type of verification to perform'
        required: false
        type: string
        default: 'comprehensive'
      target_url:
        description: 'Production URL to verify'
        required: true
        type: string
    outputs:
      verification_passed:
        description: 'Whether verification passed'
        value: ${{ jobs.verify-production.outputs.verification_passed }}
      issues_found:
        description: 'Number of issues found'
        value: ${{ jobs.verify-production.outputs.issues_found }}
      recommendation:
        description: 'Recommendations based on verification'
        value: ${{ jobs.verify-production.outputs.recommendation }}

env:
  VERIFICATION_TYPE: ${{ inputs.verification_type || 'comprehensive' }}
  TARGET_URL: ${{ inputs.target_url || '' }}
  NOTIFICATION_LEVEL: ${{ inputs.notification_level || 'warnings' }}

jobs:
  verify-production:
    name: Production Verification
    runs-on: ubuntu-latest
    outputs:
      verification_passed: ${{ steps.final-assessment.outputs.passed }}
      issues_found: ${{ steps.final-assessment.outputs.issues_count }}
      recommendation: ${{ steps.final-assessment.outputs.recommendation }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Auto-detect production URL
        id: detect-url
        run: |
          if [ -n "${{ env.TARGET_URL }}" ]; then
            PRODUCTION_URL="${{ env.TARGET_URL }}"
            echo "Using provided URL: $PRODUCTION_URL"
          else
            # Try to detect production URL from infrastructure
            echo "Auto-detecting production URL..."

            # This would typically query your infrastructure
            # For now, we'll use a placeholder approach
            PRODUCTION_URL="http://production-server"
            echo "Auto-detected URL: $PRODUCTION_URL"
          fi

          echo "production_url=$PRODUCTION_URL" >> $GITHUB_OUTPUT
          echo "PRODUCTION_URL=$PRODUCTION_URL" >> $GITHUB_ENV

      - name: Comprehensive health verification
        id: health-verification
        if: ${{ env.VERIFICATION_TYPE == 'comprehensive' || env.VERIFICATION_TYPE == 'health-only' }}
        run: |
          echo "ðŸ¥ Running comprehensive health verification..."

          HEALTH_ISSUES=0
          HEALTH_DETAILS=""

          # 1. Basic connectivity test
          echo "1ï¸âƒ£ Testing basic connectivity..."
          if curl -s --max-time 30 --head "$PRODUCTION_URL" >/dev/null 2>&1; then
            echo "âœ… Basic connectivity: PASSED"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Basic connectivity: âœ… PASSED"
          else
            echo "âŒ Basic connectivity: FAILED"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Basic connectivity: âŒ FAILED"
            HEALTH_ISSUES=$((HEALTH_ISSUES + 1))
          fi

          # 2. Response code validation
          echo "2ï¸âƒ£ Checking response codes..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 30 "$PRODUCTION_URL" || echo "000")
          if [[ "$HTTP_CODE" =~ ^(200|301|302)$ ]]; then
            echo "âœ… HTTP response code: $HTTP_CODE (PASSED)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- HTTP response: âœ… $HTTP_CODE"
          else
            echo "âŒ HTTP response code: $HTTP_CODE (FAILED)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- HTTP response: âŒ $HTTP_CODE"
            HEALTH_ISSUES=$((HEALTH_ISSUES + 1))
          fi

          # 3. Response time analysis
          echo "3ï¸âƒ£ Analyzing response times..."
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 30 "$PRODUCTION_URL" 2>/dev/null || echo "999")
          RESPONSE_TIME_MS=$(echo "$RESPONSE_TIME * 1000" | bc -l 2>/dev/null | cut -d. -f1)

          if (( $(echo "$RESPONSE_TIME < 2.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "âœ… Response time: ${RESPONSE_TIME_MS}ms (EXCELLENT)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Response time: âœ… ${RESPONSE_TIME_MS}ms"
          elif (( $(echo "$RESPONSE_TIME < 5.0" | bc -l 2>/dev/null || echo "0") )); then
            echo "âš ï¸ Response time: ${RESPONSE_TIME_MS}ms (ACCEPTABLE)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Response time: âš ï¸ ${RESPONSE_TIME_MS}ms"
          else
            echo "âŒ Response time: ${RESPONSE_TIME_MS}ms (TOO SLOW)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Response time: âŒ ${RESPONSE_TIME_MS}ms"
            HEALTH_ISSUES=$((HEALTH_ISSUES + 1))
          fi

          # 4. Content integrity check
          echo "4ï¸âƒ£ Checking content integrity..."
          CONTENT_LENGTH=$(curl -s -I --max-time 30 "$PRODUCTION_URL" | grep -i "content-length" | awk '{print $2}' | tr -d '\r' || echo "0")
          if [ "$CONTENT_LENGTH" -gt 100 ] 2>/dev/null; then
            echo "âœ… Content length: ${CONTENT_LENGTH} bytes (PASSED)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Content length: âœ… ${CONTENT_LENGTH} bytes"
          else
            echo "âš ï¸ Content length: ${CONTENT_LENGTH} bytes (MINIMAL)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- Content length: âš ï¸ ${CONTENT_LENGTH} bytes"
          fi

          # 5. API endpoint checks (if applicable)
          echo "5ï¸âƒ£ Checking API endpoints..."
          API_ENDPOINTS=("/api/health" "/api/status" "/health" "/status")
          API_WORKING=false

          for endpoint in "${API_ENDPOINTS[@]}"; do
            if curl -s --max-time 10 "${PRODUCTION_URL}${endpoint}" >/dev/null 2>&1; then
              echo "âœ… API endpoint $endpoint: AVAILABLE"
              HEALTH_DETAILS="$HEALTH_DETAILS\n- API endpoint $endpoint: âœ… AVAILABLE"
              API_WORKING=true
              break
            fi
          done

          if [ "$API_WORKING" = false ]; then
            echo "â„¹ï¸ No standard API endpoints found (may be expected)"
            HEALTH_DETAILS="$HEALTH_DETAILS\n- API endpoints: â„¹ï¸ None found"
          fi

          echo "health_issues=$HEALTH_ISSUES" >> $GITHUB_OUTPUT
          echo "health_details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$HEALTH_DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ $HEALTH_ISSUES -eq 0 ]; then
            echo "ðŸŽ‰ Health verification: ALL CHECKS PASSED"
          else
            echo "âš ï¸ Health verification: $HEALTH_ISSUES issues found"
          fi

      - name: Performance verification
        id: performance-verification
        if: ${{ env.VERIFICATION_TYPE == 'comprehensive' || env.VERIFICATION_TYPE == 'performance-only' }}
        run: |
          echo "âš¡ Running performance verification..."

          PERF_ISSUES=0
          PERF_DETAILS=""

          # 1. Load testing with multiple concurrent requests
          echo "1ï¸âƒ£ Running concurrent load test..."
          CONCURRENT_REQUESTS=10
          FAILED_REQUESTS=0

          for i in $(seq 1 $CONCURRENT_REQUESTS); do
            if ! curl -s --max-time 10 "$PRODUCTION_URL" >/dev/null 2>&1 &
            then
              FAILED_REQUESTS=$((FAILED_REQUESTS + 1))
            fi
          done
          wait

          SUCCESS_RATE=$(echo "scale=2; ($CONCURRENT_REQUESTS - $FAILED_REQUESTS) * 100 / $CONCURRENT_REQUESTS" | bc -l)
          if (( $(echo "$SUCCESS_RATE >= 95" | bc -l) )); then
            echo "âœ… Concurrent requests: ${SUCCESS_RATE}% success rate (PASSED)"
            PERF_DETAILS="$PERF_DETAILS\n- Load test: âœ… ${SUCCESS_RATE}% success"
          else
            echo "âŒ Concurrent requests: ${SUCCESS_RATE}% success rate (FAILED)"
            PERF_DETAILS="$PERF_DETAILS\n- Load test: âŒ ${SUCCESS_RATE}% success"
            PERF_ISSUES=$((PERF_ISSUES + 1))
          fi

          # 2. Response time consistency test
          echo "2ï¸âƒ£ Testing response time consistency..."
          RESPONSE_TIMES=()
          for i in {1..5}; do
            TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "$PRODUCTION_URL" 2>/dev/null || echo "999")
            RESPONSE_TIMES+=($TIME)
            echo "   Request $i: ${TIME}s"
          done

          # Calculate average (simple approach)
          AVG_TIME=0
          for time in "${RESPONSE_TIMES[@]}"; do
            AVG_TIME=$(echo "$AVG_TIME + $time" | bc -l)
          done
          AVG_TIME=$(echo "scale=3; $AVG_TIME / ${#RESPONSE_TIMES[@]}" | bc -l)
          AVG_TIME_MS=$(echo "$AVG_TIME * 1000" | bc -l | cut -d. -f1)

          if (( $(echo "$AVG_TIME < 3.0" | bc -l) )); then
            echo "âœ… Average response time: ${AVG_TIME_MS}ms (PASSED)"
            PERF_DETAILS="$PERF_DETAILS\n- Avg response time: âœ… ${AVG_TIME_MS}ms"
          else
            echo "âš ï¸ Average response time: ${AVG_TIME_MS}ms (SLOW)"
            PERF_DETAILS="$PERF_DETAILS\n- Avg response time: âš ï¸ ${AVG_TIME_MS}ms"
            PERF_ISSUES=$((PERF_ISSUES + 1))
          fi

          # 3. Memory leak detection (simulated)
          echo "3ï¸âƒ£ Checking for potential memory leaks..."
          # Make multiple requests and check if response times increase significantly
          FIRST_TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "$PRODUCTION_URL" 2>/dev/null || echo "0")
          sleep 2
          for i in {1..20}; do
            curl -s --max-time 5 "$PRODUCTION_URL" >/dev/null 2>&1 &
          done
          wait
          sleep 2
          LAST_TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "$PRODUCTION_URL" 2>/dev/null || echo "0")

          TIME_INCREASE=$(echo "$LAST_TIME - $FIRST_TIME" | bc -l 2>/dev/null || echo "0")
          if (( $(echo "$TIME_INCREASE < 1.0" | bc -l 2>/dev/null || echo "1") )); then
            echo "âœ… Memory leak check: No significant degradation (PASSED)"
            PERF_DETAILS="$PERF_DETAILS\n- Memory leak check: âœ… PASSED"
          else
            echo "âš ï¸ Memory leak check: Possible performance degradation"
            PERF_DETAILS="$PERF_DETAILS\n- Memory leak check: âš ï¸ Possible issues"
            PERF_ISSUES=$((PERF_ISSUES + 1))
          fi

          echo "performance_issues=$PERF_ISSUES" >> $GITHUB_OUTPUT
          echo "performance_details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$PERF_DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ $PERF_ISSUES -eq 0 ]; then
            echo "ðŸŽ‰ Performance verification: ALL CHECKS PASSED"
          else
            echo "âš ï¸ Performance verification: $PERF_ISSUES issues found"
          fi

      - name: Security verification
        id: security-verification
        if: ${{ env.VERIFICATION_TYPE == 'comprehensive' || env.VERIFICATION_TYPE == 'security-only' }}
        run: |
          echo "ðŸ”’ Running security verification..."

          SECURITY_ISSUES=0
          SECURITY_DETAILS=""

          # 1. Security headers check
          echo "1ï¸âƒ£ Checking security headers..."
          HEADERS=$(curl -s -I --max-time 30 "$PRODUCTION_URL" 2>/dev/null || echo "")

          EXPECTED_HEADERS=("X-Frame-Options" "X-Content-Type-Options" "X-XSS-Protection")
          MISSING_HEADERS=()

          for header in "${EXPECTED_HEADERS[@]}"; do
            if echo "$HEADERS" | grep -i "$header" >/dev/null; then
              echo "âœ… Security header $header: PRESENT"
            else
              echo "âš ï¸ Security header $header: MISSING"
              MISSING_HEADERS+=("$header")
            fi
          done

          if [ ${#MISSING_HEADERS[@]} -eq 0 ]; then
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Security headers: âœ… All present"
          else
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Security headers: âš ï¸ Missing: ${MISSING_HEADERS[*]}"
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
          fi

          # 2. HTTPS configuration check
          echo "2ï¸âƒ£ Checking HTTPS configuration..."
          if echo "$PRODUCTION_URL" | grep -q "https://"; then
            if curl -s --max-time 10 "$PRODUCTION_URL" >/dev/null 2>&1; then
              echo "âœ… HTTPS: Properly configured and working"
              SECURITY_DETAILS="$SECURITY_DETAILS\n- HTTPS: âœ… Working"
            else
              echo "âŒ HTTPS: Configuration issues detected"
              SECURITY_DETAILS="$SECURITY_DETAILS\n- HTTPS: âŒ Issues detected"
              SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
            fi
          else
            echo "âš ï¸ HTTPS: Not configured (using HTTP)"
            SECURITY_DETAILS="$SECURITY_DETAILS\n- HTTPS: âš ï¸ Not configured"
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
          fi

          # 3. Information disclosure check
          echo "3ï¸âƒ£ Checking for information disclosure..."
          RESPONSE=$(curl -s --max-time 30 "$PRODUCTION_URL" 2>/dev/null | head -n 50)

          SENSITIVE_PATTERNS=("password" "secret" "token" "api.*key" "private.*key")
          DISCLOSED_INFO=()

          for pattern in "${SENSITIVE_PATTERNS[@]}"; do
            if echo "$RESPONSE" | grep -iE "$pattern" >/dev/null; then
              DISCLOSED_INFO+=("$pattern")
            fi
          done

          if [ ${#DISCLOSED_INFO[@]} -eq 0 ]; then
            echo "âœ… Information disclosure: No sensitive data detected"
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Information disclosure: âœ… Clean"
          else
            echo "âŒ Information disclosure: Potential sensitive data exposed"
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Information disclosure: âŒ Sensitive patterns found"
            SECURITY_ISSUES=$((SECURITY_ISSUES + 1))
          fi

          # 4. Server information disclosure
          echo "4ï¸âƒ£ Checking server information disclosure..."
          SERVER_HEADER=$(echo "$HEADERS" | grep -i "server:" | head -1)
          if [ -n "$SERVER_HEADER" ]; then
            echo "â„¹ï¸ Server header disclosed: $SERVER_HEADER"
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Server info: â„¹ï¸ Disclosed"
          else
            echo "âœ… Server header: Properly hidden"
            SECURITY_DETAILS="$SECURITY_DETAILS\n- Server info: âœ… Hidden"
          fi

          echo "security_issues=$SECURITY_ISSUES" >> $GITHUB_OUTPUT
          echo "security_details<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SECURITY_DETAILS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          if [ $SECURITY_ISSUES -eq 0 ]; then
            echo "ðŸŽ‰ Security verification: ALL CHECKS PASSED"
          else
            echo "âš ï¸ Security verification: $SECURITY_ISSUES issues found"
          fi

      - name: Final assessment and recommendations
        id: final-assessment
        run: |
          echo "ðŸ“‹ Generating final assessment..."

          # Collect results from all verification steps
          HEALTH_ISSUES=${{ steps.health-verification.outputs.health_issues || '0' }}
          PERF_ISSUES=${{ steps.performance-verification.outputs.performance_issues || '0' }}
          SECURITY_ISSUES=${{ steps.security-verification.outputs.security_issues || '0' }}

          TOTAL_ISSUES=$((HEALTH_ISSUES + PERF_ISSUES + SECURITY_ISSUES))

          echo "ðŸ“Š Verification Summary:"
          echo "- Health Issues: $HEALTH_ISSUES"
          echo "- Performance Issues: $PERF_ISSUES"
          echo "- Security Issues: $SECURITY_ISSUES"
          echo "- Total Issues: $TOTAL_ISSUES"

          # Determine overall status
          if [ $HEALTH_ISSUES -eq 0 ] && [ $PERF_ISSUES -eq 0 ] && [ $SECURITY_ISSUES -eq 0 ]; then
            VERIFICATION_PASSED="true"
            RECOMMENDATION="Production system is healthy and performing well."
            echo "ðŸŽ‰ VERIFICATION PASSED: Production system is healthy!"
          elif [ $HEALTH_ISSUES -eq 0 ]; then
            VERIFICATION_PASSED="warning"
            RECOMMENDATION="Production system is functional but has performance or security concerns that should be addressed."
            echo "âš ï¸ VERIFICATION WARNING: System functional but needs attention"
          else
            VERIFICATION_PASSED="false"
            RECOMMENDATION="Production system has critical health issues that require immediate attention."
            echo "âŒ VERIFICATION FAILED: Critical issues detected!"
          fi

          echo "passed=$VERIFICATION_PASSED" >> $GITHUB_OUTPUT
          echo "issues_count=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "recommendation=$RECOMMENDATION" >> $GITHUB_OUTPUT

      - name: Generate verification report
        run: |
          echo "## ðŸ” Production Verification Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Verification Type:** ${{ env.VERIFICATION_TYPE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Target URL:** ${{ steps.detect-url.outputs.production_url }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Overall status
          case "${{ steps.final-assessment.outputs.passed }}" in
            "true")
              echo "**Overall Status:** ðŸŸ¢ PASSED" >> $GITHUB_STEP_SUMMARY
              ;;
            "warning")
              echo "**Overall Status:** ðŸŸ¡ WARNING" >> $GITHUB_STEP_SUMMARY
              ;;
            "false")
              echo "**Overall Status:** ðŸ”´ FAILED" >> $GITHUB_STEP_SUMMARY
              ;;
          esac

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Issues Found:** ${{ steps.final-assessment.outputs.issues_count }}" >> $GITHUB_STEP_SUMMARY
          echo "**Recommendation:** ${{ steps.final-assessment.outputs.recommendation }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Add detailed results if available
          if [ "${{ env.VERIFICATION_TYPE }}" = "comprehensive" ] || [ "${{ env.VERIFICATION_TYPE }}" = "health-only" ]; then
            echo "**Health Verification:**" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.health-verification.outputs.health_details }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ env.VERIFICATION_TYPE }}" = "comprehensive" ] || [ "${{ env.VERIFICATION_TYPE }}" = "performance-only" ]; then
            echo "**Performance Verification:**" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.performance-verification.outputs.performance_details }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "${{ env.VERIFICATION_TYPE }}" = "comprehensive" ] || [ "${{ env.VERIFICATION_TYPE }}" = "security-only" ]; then
            echo "**Security Verification:**" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.security-verification.outputs.security_details }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          case "${{ steps.final-assessment.outputs.passed }}" in
            "true")
              echo "1. âœ… Production system is healthy and performing well" >> $GITHUB_STEP_SUMMARY
              echo "2. ðŸ“… Continue regular monitoring and verification" >> $GITHUB_STEP_SUMMARY
              echo "3. ðŸ”„ Consider scheduling automated verifications" >> $GITHUB_STEP_SUMMARY
              ;;
            "warning")
              echo "1. ðŸ” Review performance and security warnings above" >> $GITHUB_STEP_SUMMARY
              echo "2. ðŸ“‹ Create action items to address identified issues" >> $GITHUB_STEP_SUMMARY
              echo "3. ðŸ”„ Re-run verification after implementing fixes" >> $GITHUB_STEP_SUMMARY
              ;;
            "false")
              echo "1. ðŸš¨ Address critical health issues immediately" >> $GITHUB_STEP_SUMMARY
              echo "2. ðŸ“ž Consider escalating to operations team" >> $GITHUB_STEP_SUMMARY
              echo "3. ðŸ”„ Consider rollback if issues are severe" >> $GITHUB_STEP_SUMMARY
              echo "4. ðŸ“‹ Run verification again after fixes" >> $GITHUB_STEP_SUMMARY
              ;;
          esac
