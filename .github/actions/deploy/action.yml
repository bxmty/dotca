name: "Deploy Application"
description: "Unified deployment action for all environments"

inputs:
  environment:
    description: "Target environment (staging|production)"
    required: true
  image_tag:
    description: "Docker image tag to deploy"
    required: true
  skip_tests:
    description: "Skip post-deployment tests"
    required: false
    default: "false"

outputs:
  deployment_status:
    description: "Deployment result (success|failed)"
    value: ${{ steps.final-result.outputs.status }}
  deployed_url:
    description: "URL where application was deployed"
    value: ${{ steps.final-result.outputs.url }}

runs:
  using: "composite"
  steps:
    - name: Setup deployment environment
      shell: bash
      run: |
        echo "ðŸš€ Starting deployment to ${{ inputs.environment }}"
        echo "ðŸ“¦ Image: ${{ inputs.image_tag }}"
        echo "â° $(date)"

        # Validate required environment variables
        if [[ -z "${DO_TOKEN:-}" ]]; then
          echo "::error::DO_TOKEN environment variable is required"
          exit 1
        fi

        if [[ -z "${SSH_PRIVATE_KEY:-}" ]]; then
          echo "::error::SSH_PRIVATE_KEY environment variable is required"
          exit 1
        fi

        if [[ -z "${BREVO_API_KEY:-}" ]]; then
          echo "::error::BREVO_API_KEY environment variable is required"
          exit 1
        fi

        if [[ -z "${STRIPE_SECRET_KEY:-}" ]]; then
          echo "::error::STRIPE_SECRET_KEY environment variable is required"
          exit 1
        fi

        # Set deployment environment variables
        echo "DEPLOY_ENVIRONMENT=${{ inputs.environment }}" >> $GITHUB_ENV

        # Use the actual built image tag for deployment
        echo "DOCKER_IMAGE=ghcr.io/bxmty/dotca:${{ inputs.image_tag }}" >> $GITHUB_ENV

        # Create temporary SSH key file for Terraform/Ansible
        mkdir -p ~/.ssh
        echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key

        # Configure SSH to use the key
        echo -e "Host *\n  StrictHostKeyChecking no\n  UserKnownHostsFile /dev/null\n  IdentityFile ~/.ssh/deploy_key" >> ~/.ssh/config
        chmod 600 ~/.ssh/config

        # Create Ansible vault password file if vault password is provided
        if [[ -n "${ANSIBLE_VAULT_PASSWORD:-}" ]]; then
          echo "$ANSIBLE_VAULT_PASSWORD" > ~/.ansible_vault_pass
          chmod 600 ~/.ansible_vault_pass
          echo "ANSIBLE_VAULT_PASSWORD_FILE=~/.ansible_vault_pass" >> $GITHUB_ENV
          echo "âœ… Ansible vault password file configured"
        fi

        echo "âœ… Deployment environment configured"

    - name: Setup infrastructure with Terraform
      shell: bash
      run: |
        echo "ðŸ”§ Setting up infrastructure with Terraform for ${{ inputs.environment }}..."

        cd terraform

        # Ensure remote backend is enabled for CI/CD
        echo "ðŸ”§ Ensuring remote backend is enabled for CI/CD..."
        if [[ -f "backend-remote.tf.disabled" ]]; then
          mv backend-remote.tf.disabled backend-remote.tf
          echo "Enabled remote backend for CI/CD"
        fi
        if [[ -f "backend-local.tf" ]]; then
          mv backend-local.tf backend-local.tf.disabled
          echo "Disabled local backend for CI/CD"
        fi

        # Initialize Terraform with backend credentials (only if needed)
        if [[ ! -d ".terraform" ]]; then
          echo "Initializing Terraform with remote backend..."
          terraform init \
            -backend-config="access_key=$SPACES_ACCESS_ID" \
            -backend-config="secret_key=$SPACES_SECRET_KEY" \
            -backend-config="key=dotca/terraform-${{ inputs.environment }}.tfstate"
        fi

        # Set terraform variables as environment variables
        export TF_VAR_do_token="$DO_TOKEN"
        export TF_VAR_environment="${{ inputs.environment }}"
        export TF_VAR_ssh_key_fingerprint="$SSH_KEY_FINGERPRINT"
        export TF_VAR_git_repo_url="${{ github.server_url }}/${{ github.repository }}.git"
        export TF_VAR_git_branch="${{ inputs.environment }}"
        export TF_VAR_use_existing_project="true"  # Assume project exists for CI/CD
        export TF_VAR_use_existing_firewall="true"  # Assume firewall exists for CI/CD

        # Plan the infrastructure changes
        echo "Planning infrastructure changes..."
        terraform plan -out=tfplan -no-color

        # Apply the infrastructure changes
        echo "Applying infrastructure changes..."
        terraform apply -auto-approve tfplan -no-color

        # Get the droplet IP for Ansible
        DROPLET_IP=$(terraform output -raw droplet_ip 2>/dev/null || echo "")
        if [[ -z "$DROPLET_IP" ]]; then
          echo "::error::Failed to get droplet IP from Terraform output"
          exit 1
        fi

        echo "DROPLET_IP=$DROPLET_IP" >> $GITHUB_ENV
        echo "âœ… Infrastructure setup completed - Droplet IP: $DROPLET_IP"

    - name: Deploy application with Ansible
      shell: bash
      run: |
        echo "ðŸ“¦ Deploying application with Ansible to ${{ inputs.environment }}..."

        cd ansible

        # Ensure inventory directory exists
        mkdir -p inventory

        # Generate inventory for the deployment
        # Note: Ansible playbooks expect UPPERCASE variable names for secrets/config
        # Debug: verify DOCKER_IMAGE environment variable
        echo "DEBUG: DEPLOY_DOCKER_IMAGE env var = '$DEPLOY_DOCKER_IMAGE'"
        cat > inventory/deploy.ini << EOF
        [digitalocean]
        dotca-${{ inputs.environment }} ansible_host=$DROPLET_IP

        [digitalocean:vars]
        ansible_user=root
        ansible_python_interpreter=/usr/bin/python3
        ansible_ssh_private_key_file=~/.ssh/deploy_key
        ansible_ssh_common_args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
        environment=${{ inputs.environment }}
        project_name=dotca-nextjs
        app_dir=/app
        DEPLOY_DOCKER_IMAGE=$DOCKER_IMAGE
        public_ip=$DROPLET_IP
        staging_domain=staging.boximity.ca
        next_public_environment=${{ inputs.environment }}
        next_public_api_url=${{ inputs.environment == 'production' && 'https://boximity.ca/api' || 'https://staging.boximity.ca/api' }}
        BREVO_API_KEY=${BREVO_API_KEY:-}
        STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY:-}
        STRIPE_PUBLISHABLE_KEY=${NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY:-}
        GA_PRODUCTION_ID=${NEXT_PUBLIC_PRODUCTION_GA_ID:-}
        GA_STAGING_ID=${NEXT_PUBLIC_STAGING_GA_ID:-}
        GITHUB_TOKEN=${GITHUB_TOKEN:-}
        GITHUB_USERNAME=bxmty
        EOF

        if [[ "${{ inputs.environment }}" == "production" ]]; then
          cat >> inventory/deploy.ini << EOF
        nginx_server_name=boximity.ca
        EOF
        fi

        echo "Generated Ansible inventory for deployment"

        # Debug: show inventory DOCKER_IMAGE line to verify expansion
        echo "DEBUG: Inventory DEPLOY_DOCKER_IMAGE line:"
        grep "DEPLOY_DOCKER_IMAGE" inventory/deploy.ini || echo "DEPLOY_DOCKER_IMAGE not found in inventory!"

        # Install required Ansible Galaxy roles
        echo "ðŸ“¦ Installing Ansible Galaxy roles..."
        ansible-galaxy install -r requirements.yml

        # Run the appropriate Ansible playbook
        PLAYBOOK="${{ inputs.environment }}-deploy.yml"
        if [[ ! -f "$PLAYBOOK" ]]; then
          echo "::error::Ansible playbook $PLAYBOOK not found"
          exit 1
        fi

        echo "Executing Ansible playbook: $PLAYBOOK"
        echo "DEPLOY_DOCKER_IMAGE=$DEPLOY_DOCKER_IMAGE"
        export DEPLOY_DOCKER_IMAGE="$DOCKER_IMAGE"
        # Enable colors and cleaner output
        export ANSIBLE_FORCE_COLOR=1
        # Reduce verbosity - suppress skipped hosts
        export ANSIBLE_DISPLAY_SKIPPED_HOSTS=False
        # Note: Callback is configured in ansible.cfg (default with yaml format)
        # Timer callback requires ansible.posix collection, so we'll skip it for now
        # Run playbook with cleaner output
        # --diff shows only file changes (when files are modified)
        # Removed -v flag for less verbose output
        ansible-playbook -i inventory/deploy.ini "$PLAYBOOK" --diff

        echo "âœ… Application deployment completed"

    - name: Cleanup sensitive files
      if: always()
      shell: bash
      run: |
        echo "ðŸ§¹ Cleaning up sensitive files..."

        # Remove SSH key file
        rm -f ~/.ssh/deploy_key

        # Remove Ansible vault password file
        rm -f ~/.ansible_vault_pass

        # Remove generated inventory with sensitive data
        rm -f ansible/inventory/deploy.ini

        # Clean up Terraform plan files
        rm -f terraform/tfplan
        rm -f terraform/destroy-plan

        echo "âœ… Sensitive files cleaned up"

    - name: Run post-deployment tests
      if: inputs.skip_tests != 'true'
      uses: ./.github/actions/test-runner
      with:
        test_type: smoke
        environment: ${{ inputs.environment }}
        app_url: ${{ inputs.environment == 'production' && 'https://boximity.ca' || 'https://staging.boximity.ca' }}
        fail_fast: false
        timeout_minutes: 5

    - name: Verify deployment
      id: verify
      shell: bash
      run: |
        echo "ðŸ” Verifying deployment..."

        DEPLOYMENT_SUCCESS=true

        # Test basic connectivity to the deployed application
        DEPLOY_URL=""
        case "${{ inputs.environment }}" in
          "production")
            DEPLOY_URL="https://boximity.ca"
            ;;
          "staging")
            DEPLOY_URL="https://staging.boximity.ca"
            ;;
          *)
            DEPLOY_URL="http://$DROPLET_IP"
            ;;
        esac

        echo "Testing connectivity to $DEPLOY_URL"

        # Wait a moment for services to fully start
        sleep 10

        # Test HTTP connectivity
        if curl -f --max-time 30 --silent "$DEPLOY_URL/api/health" > /dev/null 2>&1; then
          echo "âœ… Application health check passed"
        else
          echo "âš ï¸ Application health check failed - may still be starting"
          # Don't fail immediately, give it more time
          sleep 20
          if curl -f --max-time 30 --silent "$DEPLOY_URL/api/health" > /dev/null 2>&1; then
            echo "âœ… Application health check passed (after retry)"
          else
            echo "âŒ Application health check failed"
            DEPLOYMENT_SUCCESS=false
          fi
        fi

        # Test basic HTTP response
        if curl --max-time 10 --silent "$DEPLOY_URL" > /dev/null 2>&1; then
          echo "âœ… HTTP connectivity confirmed"
        else
          echo "âŒ HTTP connectivity failed"
          DEPLOYMENT_SUCCESS=false
        fi

        # Log deployment details for debugging
        echo "Deployment Details:" >&2
        echo "  Environment: ${{ inputs.environment }}" >&2
        echo "  Image: ${{ inputs.image_tag }}" >&2
        echo "  Droplet IP: $DROPLET_IP" >&2
        echo "  Deploy URL: $DEPLOY_URL" >&2
        echo "  Terraform State: terraform/terraform.tfstate" >&2

        echo "verification_success=$DEPLOYMENT_SUCCESS" >> $GITHUB_OUTPUT
        echo "deploy_url=$DEPLOY_URL" >> $GITHUB_OUTPUT

    - name: Generate deployment summary
      id: final-result
      shell: bash
      run: |
        echo "ðŸ“‹ Generating deployment summary..."

        # Determine deployment status
        if [ "${{ steps.verify.outputs.verification_success }}" = "true" ]; then
          DEPLOYMENT_STATUS="success"
          echo "ðŸŽ‰ Deployment completed successfully"
        else
          DEPLOYMENT_STATUS="failed"
          echo "âŒ Deployment verification failed"

          # Log additional debugging information on failure
          echo "::warning::Deployment verification failed. Check the following:"
          echo "::warning::- Application may still be starting up"
          echo "::warning::- Check firewall rules and security groups"
          echo "::warning::- Verify SSL certificate configuration"
          echo "::warning::- Review Ansible playbook execution logs"
        fi

        DEPLOY_URL="${{ steps.verify.outputs.deploy_url }}"

        echo "status=$DEPLOYMENT_STATUS" >> $GITHUB_OUTPUT
        echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT

        echo "ðŸ“Š Deployment Summary:"
        echo "  Environment: ${{ inputs.environment }}"
        echo "  Status: $DEPLOYMENT_STATUS"
        echo "  URL: $DEPLOY_URL"
        echo "  Image: ${{ inputs.image_tag }}"
        echo "  Droplet IP: $DROPLET_IP"
        echo "  Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"

        # Create deployment log artifact
        mkdir -p deployment-logs
        echo "Deployment Summary" > deployment-logs/summary.txt
        echo "==================" >> deployment-logs/summary.txt
        echo "Environment: ${{ inputs.environment }}" >> deployment-logs/summary.txt
        echo "Status: $DEPLOYMENT_STATUS" >> deployment-logs/summary.txt
        echo "URL: $DEPLOY_URL" >> deployment-logs/summary.txt
        echo "Image: ${{ inputs.image_tag }}" >> deployment-logs/summary.txt
        echo "Droplet IP: $DROPLET_IP" >> deployment-logs/summary.txt
        echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> deployment-logs/summary.txt
