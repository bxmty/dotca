---
# Ansible playbook for setting up the Staging environment for dotca
# With optimizations for Next.js deployment and best practices

# Pre-deployment validation and temporary directory setup
- name: Pre-deployment validation and setup
  hosts: digitalocean
  become: true
  gather_facts: true
  vars:
    project_name: dotca-nextjs
    git_repo_url: "{{ lookup('env', 'GIT_REPO_URL') }}"
    git_branch: staging
    app_dir: /app
    public_ip: '{{ ansible_host }}'
    brevo_api_key: "{{ lookup('env', 'BREVO_API_KEY') }}"
    stripe_secret_key: "{{ lookup('env', 'STRIPE_SECRET_KEY') }}"
    stripe_publishable_key: "{{ lookup('env', 'STRIPE_PUBLISHABLE_KEY') }}"
    ga_staging_id: "{{ lookup('env', 'GA_STAGING_ID') }}"
    docker_compose_file: '{{ app_dir }}/repo/docker-compose.yml'
  tasks:
    - name: Validate required environment variables
      ansible.builtin.assert:
        that:
          - git_repo_url is defined and git_repo_url != ""
          - brevo_api_key is defined and brevo_api_key != ""
          - stripe_secret_key is defined and stripe_secret_key != ""
          - stripe_publishable_key is defined and stripe_publishable_key != ""
        fail_msg: Required environment variables are missing. Please check GIT_REPO_URL,
          BREVO_API_KEY, STRIPE_SECRET_KEY, and STRIPE_PUBLISHABLE_KEY.
      tags: [validation]
    - name: Check available disk space
      ansible.builtin.shell: |
        set -o pipefail
        df -h / | awk 'NR==2 {print $5}' | sed 's/%//'
      register: disk_usage
      changed_when: false
      tags: [validation]
    - name: Fail if disk space is too low
      ansible.builtin.fail:
        msg: 'Insufficient disk space: {{ disk_usage.stdout }}% used. Need at least
          15% free space.'
      when: disk_usage.stdout | int > 85
      tags: [validation]
    - name: Ensure /tmp directory exists with proper permissions
      ansible.builtin.file:
        path: /tmp
        state: directory
        mode: '1777'
      tags: [setup]
    - name: Display deployment info
      ansible.builtin.debug:
        msg:
          - Deploying {{ project_name }} to {{ ansible_host }}
          - 'Git repository: {{ git_repo_url }}'
          - 'Branch: {{ git_branch }}'
          - 'Disk usage: {{ disk_usage.stdout }}%'
      tags: [info]
- name: Setup Staging environment for dotca
  hosts: digitalocean
  become: true
  vars:
    project_name: dotca-nextjs
    git_repo_url: "{{ lookup('env', 'GIT_REPO_URL') }}"
    git_branch: staging
    app_dir: /app
    public_ip: '{{ ansible_host }}'
    brevo_api_key: "{{ lookup('env', 'BREVO_API_KEY') }}"
    stripe_secret_key: "{{ lookup('env', 'STRIPE_SECRET_KEY') }}"
    stripe_publishable_key: "{{ lookup('env', 'STRIPE_PUBLISHABLE_KEY') }}"
    ga_staging_id: "{{ lookup('env', 'GA_STAGING_ID') }}"
    docker_compose_file: '{{ app_dir }}/repo/docker-compose.yml'
  handlers:
    - name: Restart nginx
      ansible.builtin.systemd:
        name: nginx
        state: restarted
        enabled: true
      tags: [nginx]
    - name: Restart docker
      ansible.builtin.systemd:
        name: docker
        state: restarted
        enabled: true
      tags: [docker]
  tasks:
    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600
      tags: [packages]
    - name: Upgrade packages safely
      ansible.builtin.apt:
        upgrade: safe
        autoremove: true
        autoclean: true
      tags: [packages]
    - name: Install required system packages
      ansible.builtin.apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - git
          - python3-pip
          - jq
          - nginx
          - htop
          - unzip
        state: present
        update_cache: true
      tags: [packages]
    - name: Add Docker's official GPG key
      ansible.builtin.apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present
      tags: [docker, packages]
    - name: Add Docker repository
      ansible.builtin.apt_repository:
        repo: deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }}
          stable
        state: present
        update_cache: true
      tags: [docker, packages]
    - name: Install Docker Engine
      ansible.builtin.apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
          - docker-compose-plugin
        state: present
        update_cache: true
      register: docker_install_result
      retries: 3
      delay: 5
      until: docker_install_result is success
      tags: [docker, packages]
    - name: Configure Docker daemon for better resource management
      ansible.builtin.copy:
        dest: /etc/docker/daemon.json
        content: |
          {
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "10m",
              "max-file": "3"
            },
            "storage-driver": "overlay2",
            "default-ulimits": {
              "nofile": {
                "name": "nofile",
                "hard": 65536,
                "soft": 65536
              }
            }
          }
        mode: '0644'
      notify: Restart docker
      tags: [docker, config]
    - name: Install and configure NTP for time synchronization
      block:
        - name: Install NTP
          ansible.builtin.apt:
            name: ntp
            state: present
          tags: [time]
        - name: Configure NTP to use reliable time servers
          ansible.builtin.lineinfile:
            path: /etc/ntp.conf
            regexp: ^server
            line: server time.nist.gov iburst
            state: present
            backup: true
          notify: restart ntp
          tags: [time, config]
        - name: Start and enable NTP service
          ansible.builtin.systemd:
            name: ntp
            state: started
            enabled: true
          tags: [time]
    - name: Set timezone to Eastern Time
      ansible.builtin.file:
        src: /usr/share/zoneinfo/America/New_York
        dest: /etc/localtime
        state: link
        force: true
      tags: [time]
    - name: Set timezone in /etc/timezone
      ansible.builtin.copy:
        dest: /etc/timezone
        content: "America/New_York\n"
        owner: root
        group: root
        mode: '0644'
      tags: [time]
    - name: Start and enable Docker service
      ansible.builtin.systemd:
        name: docker
        state: started
        enabled: true
      register: docker_service_result
      retries: 3
      delay: 5
      until: docker_service_result is success
      tags: [docker]
    - name: Detect Docker Compose command
      ansible.builtin.shell: |
        if docker compose version >/dev/null 2>&1; then
          echo "docker compose"
        elif command -v docker-compose >/dev/null 2>&1; then
          echo "docker-compose"
        else
          echo "none"
        fi
      register: compose_detection
      changed_when: false
      tags: [docker]
    - name: Install docker-compose via pip if not available
      ansible.builtin.pip:
        name: docker-compose
        state: present
        executable: pip3
      when: compose_detection.stdout == "none"
      tags: [docker, packages]
    - name: Set Docker Compose command variable
      ansible.builtin.set_fact:
        docker_compose_cmd: "{{ compose_detection.stdout if compose_detection.stdout != 'none' else 'docker-compose' }}"
        is_compose_v2: "{{ compose_detection.stdout == 'docker compose' }}"
      tags: [docker]
    - name: Verify Docker Compose is working
      ansible.builtin.command: '{{ docker_compose_cmd }} version'
      register: compose_version_check
      changed_when: false
      tags: [docker, validation]
    - name: Display Docker Compose version
      ansible.builtin.debug:
        msg: "Using {{ docker_compose_cmd }}: {{ compose_version_check.stdout_lines[0] if compose_version_check.stdout_lines else 'Version check failed' }}"
      tags: [docker, info]
    - name: Create application directory with proper permissions
      ansible.builtin.file:
        path: '{{ app_dir }}'
        state: directory
        mode: '0755'
        owner: root
        group: root
      tags: [setup]
    - name: Clone or update the repository
      ansible.builtin.git:
        repo: '{{ git_repo_url }}'
        dest: '{{ app_dir }}/repo'
        version: '{{ git_branch }}'
        force: true
        update: true
      register: git_operation
      retries: 3
      delay: 10
      until: git_operation is success
      tags: [git]
    - name: Verify Next.js configuration file exists
      ansible.builtin.stat:
        path: '{{ app_dir }}/repo/next.config.js'
      register: next_config
      tags: [validation]
    - name: Fail if Next.js configuration is missing
      ansible.builtin.fail:
        msg: Missing Next.js configuration file. Please ensure next.config.js exists
          in the repository.
      when: not next_config.stat.exists
      tags: [validation]
    - name: Verify Docker Compose file exists
      ansible.builtin.stat:
        path: '{{ docker_compose_file }}'
      register: compose_file_check
      tags: [validation]
    - name: Fail if Docker Compose file is missing
      ansible.builtin.fail:
        msg: Docker Compose file not found at {{ docker_compose_file }}
      when: not compose_file_check.stat.exists
      tags: [validation]

    # DEPLOYMENT TASKS START HERE
    - name: Create .env file for docker-compose
      ansible.builtin.copy:
        dest: '{{ app_dir }}/repo/.env'
        mode: '0600'  # Restrict permissions for security
        content: |
          NODE_ENV=production
          NEXT_PUBLIC_API_URL=http://{{ public_ip }}/api
          NEXT_PUBLIC_ENVIRONMENT=staging
          BREVO_API_KEY={{ brevo_api_key }}
          STRIPE_SECRET_KEY={{ stripe_secret_key }}
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY={{ stripe_publishable_key }}
          NEXT_PUBLIC_STAGING_GA_ID={{ ga_staging_id }}
      tags: [config, deployment]
    - name: Stop existing Docker Compose services gracefully
      ansible.builtin.shell: |
        cd {{ app_dir }}/repo
        if [ -f docker-compose.yml ]; then
          {{ docker_compose_cmd }} down --remove-orphans --volumes || true
          sleep 5
        fi
      args:
        chdir: '{{ app_dir }}/repo'
      register: docker_down_result
      changed_when: docker_down_result.rc == 0
      tags: [docker, deployment]
    - name: Create Docker cleanup script from template
      ansible.builtin.template:
        src: docker_cleanup.sh.j2
        dest: /tmp/docker_cleanup.sh
        mode: '0755'
      tags: [docker, cleanup]
    - name: Force stop any containers using port 8080
      ansible.builtin.command: /tmp/docker_cleanup.sh
      register: port_cleanup
      changed_when: port_cleanup.rc == 0
      tags: [docker, cleanup]
    - name: Remove all stopped containers
      ansible.builtin.shell: |
        echo "Removing all stopped containers..."
        docker container prune -f || true
      changed_when: false
      tags: [docker, cleanup]
    - name: Clean up Docker resources
      ansible.builtin.shell: |
        echo "Cleaning up Docker system..."
        docker system prune -f || true
        docker volume prune -f || true
        docker network prune -f || true
      changed_when: false
      tags: [docker, cleanup]
    - name: Wait for port to be released
      ansible.builtin.wait_for:
        port: 8080
        host: localhost
        state: stopped
        timeout: 60
        delay: 5
      failed_when: false
      tags: [docker, validation]
    - name: Additional wait for containers to fully stop
      ansible.builtin.pause:
        seconds: 10
      tags: [docker, validation]
    - name: Create port verification script from template
      ansible.builtin.template:
        src: port_verification.sh.j2
        dest: /tmp/port_verification.sh
        mode: '0755'
      tags: [docker, validation]
    - name: Verify port 8080 is free
      ansible.builtin.command: /tmp/port_verification.sh
      register: port_check
      changed_when: false
      tags: [docker, validation]
    - name: Display port cleanup results
      ansible.builtin.debug:
        msg: '{{ port_check.stdout_lines }}'
      tags: [docker, debug]
    - name: Build Docker images with improved caching
      ansible.builtin.shell: |
        cd {{ app_dir }}/repo
        export DOCKER_BUILDKIT=1
        export COMPOSE_DOCKER_CLI_BUILD=1
        {{ docker_compose_cmd }} build --no-cache --parallel
      args:
        chdir: '{{ app_dir }}/repo'
      environment:
        DOCKER_BUILDKIT: '1'
        COMPOSE_DOCKER_CLI_BUILD: '1'
      register: docker_build
      changed_when: docker_build.rc == 0
      retries: 2
      delay: 30
      until: docker_build is success
      tags: [docker, build]
    - name: Start Docker Compose services
      ansible.builtin.shell: |
        cd {{ app_dir }}/repo
        {{ docker_compose_cmd }} up -d --remove-orphans
      args:
        chdir: '{{ app_dir }}/repo'
      register: docker_up
      changed_when: docker_up.rc == 0
      retries: 2
      delay: 10
      until: docker_up is success
      tags: [docker, deployment]
    - name: Wait for application to be ready
      ansible.builtin.uri:
        url: http://localhost:8080/health
        method: GET
        status_code: 200
        timeout: 10
      register: health_check
      until: health_check.status == 200
      retries: 15
      delay: 10
      ignore_errors: true
      tags: [health-check, deployment]
    - name: Display container status
      ansible.builtin.command: '{{ docker_compose_cmd }} ps'
      args:
        chdir: '{{ app_dir }}/repo'
      register: container_status
      changed_when: false
      tags: [info, deployment]
    - name: Show container logs if health check failed
      ansible.builtin.command: '{{ docker_compose_cmd }} logs --tail=50'
      args:
        chdir: '{{ app_dir }}/repo'
      when: health_check is failed
      register: container_logs
      changed_when: false
      tags: [debug, deployment]
    - name: Display logs if health check failed
      ansible.builtin.debug:
        msg: '{{ container_logs.stdout_lines }}'
      when: health_check is failed and container_logs is defined
      tags: [debug, deployment]
    - name: Configure optimized Nginx
      ansible.builtin.template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
        mode: '0644'
        backup: true
      notify: Restart nginx
      tags: [nginx, config]
    - name: Configure Nginx site for Next.js application
      ansible.builtin.template:
        src: nextjs-site.conf.j2
        dest: /etc/nginx/sites-available/nextjs-app
        mode: '0644'
        vars:
          server_name: "{{ domain_name | default('_') }}"
        backup: true
      notify: Restart nginx
      tags: [nginx, config]
    - name: Enable Nginx site configuration
      ansible.builtin.file:
        src: /etc/nginx/sites-available/nextjs-app
        dest: /etc/nginx/sites-enabled/nextjs-app
        state: link
      notify: Restart nginx
      tags: [nginx, config]
    - name: Remove default Nginx site
      ansible.builtin.file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: Restart nginx
      tags: [nginx, config]
    - name: Test Nginx configuration
      ansible.builtin.command: nginx -t
      register: nginx_test
      changed_when: false
      tags: [nginx, validation]
    - name: Display Nginx test results if failed
      ansible.builtin.debug:
        msg: 'Nginx configuration test failed: {{ nginx_test.stderr_lines }}'
      when: nginx_test.rc != 0
      tags: [nginx, debug]
    - name: Fail if Nginx configuration is invalid
      ansible.builtin.fail:
        msg: Nginx configuration is invalid. Please check the configuration.
      when: nginx_test.rc != 0
      tags: [nginx, validation]
    - name: Configure UFW firewall rules
      become: true
      ansible.builtin.shell: |
        echo "Configuring UFW firewall rules..."
        for port in 22 80 443 8080; do
          echo "Allowing port $port/tcp"
          ufw allow $port/tcp comment "$port - Required for {{ project_name }}"
        done
        echo "UFW rules configured successfully"
      register: ufw_rules_result
      changed_when: ufw_rules_result.rc == 0
      tags: [firewall, security]
    - name: Enable UFW firewall
      become: true
      ansible.builtin.shell: |
        # Set default policies
        ufw --force default deny incoming
        ufw --force default allow outgoing
        # Enable UFW
        ufw --force enable
        # Show status
        ufw status verbose
      register: ufw_enable_result
      changed_when: ufw_enable_result.rc == 0
      tags: [firewall, security]
    - name: Display UFW configuration
      ansible.builtin.debug:
        msg: '{{ ufw_enable_result.stdout_lines }}'
      tags: [firewall, info]
    - name: Create enhanced monitoring and recovery script
      ansible.builtin.template:
        src: monitor.sh.j2
        dest: '{{ app_dir }}/monitor.sh'
        mode: '0755'
      tags: [monitoring, scripts]
    - name: Set up monitoring cron job
      ansible.builtin.cron:
        name: Monitor {{ project_name }}
        minute: '*/10'  # Check every 10 minutes instead of 15
        job: '{{ app_dir }}/monitor.sh'
        user: root
        state: present
      tags: [monitoring, cron]
    - name: Create log rotation for monitoring
      ansible.builtin.template:
        src: logrotate.conf.j2
        dest: /etc/logrotate.d/{{ project_name }}
        mode: '0644'
      tags: [monitoring, logs]
    - name: Display deployment completion message
      ansible.builtin.debug:
        msg:
          - ===============================================
          - ðŸŽ‰ Deployment completed successfully!
          - ===============================================
          - 'Application URL: http://{{ public_ip }}'
          - 'Health check: http://{{ public_ip }}/health'
          - "Container status: {{ container_status.stdout_lines if container_status.stdout_lines else 'Check manually' }}"
          - 'Docker Compose command: {{ docker_compose_cmd }}'
          - 'Monitoring: {{ app_dir }}/monitor.sh (runs every 10 minutes)'
          - 'Logs: {{ app_dir }}/monitoring.log'
          - ===============================================
      tags: [info, deployment]

# Separate play for Let's Encrypt SSL setup
- name: Setup Let's Encrypt SSL with Nginx
  hosts: digitalocean
  become: true
  vars:
    domain_name: staging.boximity.ca
    email_address: matticem@boximity.ca
  tasks:
    - name: Install Certbot and Nginx plugin
      ansible.builtin.package:
        name: [certbot, python3-certbot-nginx]
        state: present
      register: certbot_install
      retries: 3
      delay: 5
      until: certbot_install is success
      tags: [ssl, packages]
    - name: Check if certificate already exists
      ansible.builtin.stat:
        path: /etc/letsencrypt/live/{{ domain_name }}/cert.pem
      register: cert_file
      tags: [ssl, validation]
    - name: Update Nginx configuration with domain name
      ansible.builtin.replace:
        path: /etc/nginx/sites-available/nextjs-app
        regexp: 'server_name _;'
        replace: 'server_name {{ domain_name }};'
      when: not cert_file.stat.exists
      notify: Restart nginx
      tags: [ssl, nginx]
    - name: Test Nginx configuration before SSL
      ansible.builtin.command: nginx -t
      register: nginx_ssl_test
      changed_when: false
      when: not cert_file.stat.exists
      tags: [ssl, validation]
    - name: Restart Nginx before certificate request
      ansible.builtin.systemd:
        name: nginx
        state: restarted
      when: not cert_file.stat.exists and nginx_ssl_test.rc == 0
      tags: [ssl, nginx]
    - name: Wait for Nginx to be ready
      ansible.builtin.uri:
        url: http://{{ domain_name }}/health
        method: GET
        status_code: 200
        timeout: 10
      register: domain_check
      retries: 5
      delay: 5
      ignore_errors: true
      when: not cert_file.stat.exists
      tags: [ssl, validation]
    - name: Obtain SSL certificate from Let's Encrypt
      ansible.builtin.command: >
        certbot --nginx -d {{ domain_name }}
        --non-interactive --agree-tos  --email {{ email_address }}
        --redirect --no-eff-email
      when: not cert_file.stat.exists and domain_check is success
      register: certbot_result
      changed_when: certbot_result.rc == 0
      retries: 2
      delay: 30
      until: certbot_result is success
      tags: [ssl, certificate]
    - name: Display certificate generation results
      ansible.builtin.debug:
        msg:
          - "SSL Certificate Status: {{ 'Already exists' if cert_file.stat.exists else 'Newly generated' }}"
          - 'Domain: {{ domain_name }}'
          - 'Certificate path: /etc/letsencrypt/live/{{ domain_name }}/'
      tags: [ssl, info]
    - name: Set up automatic certificate renewal
      ansible.builtin.cron:
        name: Let's Encrypt renewal for {{ domain_name }}
        special_time: daily
        job: certbot renew --quiet --nginx --no-random-sleep-on-renew
        user: root
        state: present
      tags: [ssl, cron]
    - name: Verify SSL configuration
      ansible.builtin.uri:
        url: https://{{ domain_name }}/health
        method: GET
        status_code: 200
        timeout: 10
        validate_certs: true
      register: ssl_check
      retries: 3
      delay: 5
      ignore_errors: true
      when: not cert_file.stat.exists and certbot_result is success
      tags: [ssl, validation]
    - name: Display final SSL status
      ansible.builtin.debug:
        msg:
          - ðŸ”’ SSL Setup Complete!
          - 'HTTPS URL: https://{{ domain_name }}'
          - "SSL Check: {{ 'Passed' if ssl_check is success else 'Failed - check manually' }}"
          - 'Auto-renewal: Configured (daily check)'
      tags: [ssl]
