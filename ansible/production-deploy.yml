---
# Ansible playbook for setting up the Production environment for dotca
# With optimizations for Next.js deployment and geerlingguy certbot role

# Add a pre-task to fix temporary directory issues
- name: Fix temporary directory issues
  hosts: digitalocean
  become: true
  gather_facts: false
  tasks:
    - name: Ensure /tmp directory exists with proper permissions
      ansible.builtin.raw: |
        mkdir -p /tmp
        chmod 1777 /tmp
        df -h /tmp

- name: Setup Production environment for dotca
  hosts: digitalocean
  become: true
  vars:
    project_name: dotca-nextjs
    git_repo_url: "{{ lookup('env', 'GIT_REPO_URL') }}"
    git_branch: main
    app_dir: /app
    public_ip: "{{ ansible_host }}"
    brevo_api_key: "{{ lookup('env', 'BREVO_API_KEY') }}"
    stripe_secret_key: "{{ lookup('env', 'STRIPE_SECRET_KEY') }}"
    stripe_publishable_key: "{{ lookup('env', 'STRIPE_PUBLISHABLE_KEY') }}"
    ga_production_id: "{{ lookup('env', 'GA_PRODUCTION_ID') }}"
    docker_compose_file: "{{ app_dir }}/repo/docker-compose.yml"
    # GitHub Container Registry settings for promoted images
    github_token: "{{ lookup('env', 'GITHUB_TOKEN') }}"
    github_username: "{{ lookup('env', 'GITHUB_USERNAME') }}"
    # Production image configuration - uses promoted images from GHCR
    docker_image_override: "{{ lookup('env', 'DOCKER_IMAGE') }}"
    github_repo_from_url: "{{ git_repo_url | default('') }}"
    # Default to main tag (promoted production image)
    docker_image: "{{ docker_image_override if docker_image_override else 'ghcr.io/bxtech/dotca:main' }}"

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Upgrade all packages
      apt:
        upgrade: yes

    - name: Install required packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - git
          - python3-pip
          - jq
          - nginx
        state: present
        update_cache: yes

    - name: Add Docker's official GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        update_cache: yes

    - name: Install Docker Engine
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
        update_cache: yes
      register: docker_install_result
      retries: 3
      delay: 5
      until: docker_install_result is success

    - name: Install NTP for time synchronization
      apt:
        name: ntp
        state: present
        update_cache: yes

    - name: Configure NTP to use time.nist.gov
      lineinfile:
        path: /etc/ntp.conf
        regexp: '^server'
        line: 'server time.nist.gov iburst'
        state: present
        backup: yes

    - name: Restart NTP service
      systemd:
        name: ntp
        state: restarted
        enabled: yes

    - name: Set timezone to Eastern Time
      command: timedatectl set-timezone America/New_York
      changed_when: false

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
      register: docker_service_result
      retries: 3
      delay: 5
      until: docker_service_result is success

    - name: Remove old docker-compose if exists
      apt:
        name: docker-compose
        state: absent
        purge: yes
      ignore_errors: yes

    - name: Install latest Docker Compose v2
      get_url:
        url: "https://github.com/docker/compose/releases/latest/download/docker-compose-{{ ansible_system }}-{{ ansible_architecture }}"
        dest: /usr/local/bin/docker-compose
        mode: '0755'
      register: compose_install

    - name: Create symlink for docker-compose
      file:
        src: /usr/local/bin/docker-compose
        dest: /usr/bin/docker-compose
        state: link
      when: compose_install is changed

    - name: Verify Docker Compose v2 installation
      command: docker-compose --version
      register: compose_version
      changed_when: false

    - name: Display Docker Compose version
      debug:
        msg: "Docker Compose version: {{ compose_version.stdout }}"

    - name: Verify Docker Compose binary location
      command: which docker-compose
      register: compose_location
      changed_when: false

    - name: Display Docker Compose location
      debug:
        msg: "Docker Compose location: {{ compose_location.stdout }}"

    - name: Verify Docker Compose v2 compatibility
      fail:
        msg: |
          Docker Compose version {{ compose_version.stdout }} is not compatible.
          Expected Docker Compose v2+ for production deployment.
          Please ensure the latest version is installed.
      when: "'v2' not in compose_version.stdout and '2.' not in compose_version.stdout"

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Clone the repository
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
      register: git_clone
      retries: 3
      delay: 10
      until: git_clone is success

    - name: Verify Next.js configuration file
      stat:
        path: "{{ app_dir }}/repo/next.config.js"
      register: next_config

    - name: Fail if Next.js configuration is missing
      fail:
        msg: "Missing Next.js configuration file. Please ensure next.config.js exists in the repository."
      when: not next_config.stat.exists

    # DEPLOYMENT TASKS START HERE
    - name: Pull latest changes from git
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
        update: yes
      register: git_pull
      retries: 3
      delay: 5
      until: git_pull is success

    - name: Stop existing Docker Compose services
      command: docker-compose down -v --remove-orphans
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_down_result
      ignore_errors: yes

    - name: Clean up any remaining Docker resources
      shell: |
        docker system prune -f
        docker volume prune -f
        docker network prune -f
      ignore_errors: yes

    - name: Stop any other containers using port 8080
      shell: |
        if docker ps -q --filter publish=8080 | grep -q .; then
          docker stop $(docker ps -q --filter publish=8080)
        fi
      ignore_errors: yes

    - name: Login to GitHub Container Registry
      ansible.builtin.command: bash -c 'set -o pipefail && echo "{{ github_token }}" | docker login ghcr.io -u {{ github_username }} --password-stdin'
      when: github_token is defined and github_username is defined
      register: docker_login
      retries: 3
      delay: 5
      until: docker_login is success
      changed_when: false

    - name: Verify promoted production image exists in GHCR
      ansible.builtin.command: |
        bash -c "
        if [ -z '{{ docker_image | default('') }}' ]; then 
          echo 'ERROR: docker_image variable is empty or undefined'
          exit 1
        fi
        echo 'Checking if promoted production image exists: {{ docker_image }}'
        docker manifest inspect '{{ docker_image }}'
        "
      register: production_image_exists
      ignore_errors: true
      changed_when: false
      when: docker_image is defined and docker_image != ""

    - name: Set production_image_exists to failed state if docker_image is empty
      ansible.builtin.set_fact:
        production_image_exists:
          rc: 1
          stdout: ""
          stderr: "docker_image variable is empty or undefined"
          failed: true
      when: docker_image is not defined or docker_image == ""

    - name: Try alternative production image names if primary fails
      ansible.builtin.command: |
        bash -c "echo \"Trying alternative production image: ghcr.io/{{ github_username }}/dotca:main\"; docker manifest inspect \"ghcr.io/{{ github_username }}/dotca:main\""
      register: alt_production_image_exists
      ignore_errors: true
      changed_when: false
      when: 
        - (production_image_exists.rc | default(1)) != 0
        - github_username is defined
        - github_username != ""

    - name: Set production image availability status variables
      ansible.builtin.set_fact:
        primary_production_image_status: "{{ 'YES' if (production_image_exists.rc | default(1) == 0) else 'NO' }}"
        alt_production_image_status: "{{ 'YES' if (alt_production_image_exists.rc | default(1) == 0) else 'NO' }}"
        any_production_image_found: "{{ (production_image_exists.rc | default(1) == 0) or (alt_production_image_exists.rc | default(1) == 0) }}"

    - name: Display production image availability
      ansible.builtin.debug:
        msg: 
          - "Production image {{ docker_image | default('undefined') }} exists: {{ primary_production_image_status }}"
          - "Alternative production image exists: {{ alt_production_image_status }}"
          - ""
          - "{{ 'SUCCESS: Found promoted production image!' if any_production_image_found else 'ERROR: No promoted production images found!' }}"
          - ""
          - "If no images found, check:"
          - "1. Has the image promotion workflow completed? Check: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml"
          - "2. Was the promotion approved in the GitHub environment?"
          - "3. Does the image name match what was created by the promotion workflow?"
          - "4. Are you authenticated to GHCR properly?"

    - name: Use alternative production image if primary failed
      ansible.builtin.set_fact:
        docker_image: "ghcr.io/{{ github_username }}/dotca:main"
      when: 
        - (production_image_exists.rc | default(1)) != 0
        - alt_production_image_exists is defined
        - (alt_production_image_exists.rc | default(1)) == 0

    - name: Fail if no promoted production images found
      ansible.builtin.fail:
        msg: |
          No promoted production images found in GHCR! 
          
          This means the image promotion workflow hasn't completed yet or failed.
          
          Steps to fix:
          1. Check image promotion workflow: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml
          2. Ensure staging deployment completed successfully
          3. Trigger and approve the image promotion workflow
          4. Verify the promoted image exists in GHCR
          
          Expected image locations:
          - {{ docker_image | default('undefined') }}
          - ghcr.io/{{ github_username }}/dotca:main (if username available)
          
          Current workflow status:
          - Staging deployment: Check staging-deploy.yml workflow
          - Image promotion: Check image-promotion.yml workflow
          - Production deployment: This workflow (requires promoted image)
      when: not (any_production_image_found | default(false))

    - name: Generate docker-compose.yml from template
      ansible.builtin.template:
        src: docker-compose.yml.j2
        dest: "{{ app_dir }}/repo/docker-compose.yml"
        mode: '0644'
        backup: true
      vars:
        node_env: production
        next_public_api_url: "http://{{ public_ip }}/api"
        next_public_environment: production

    - name: Display generated docker-compose.yml for debugging
      ansible.builtin.command: cat "{{ app_dir }}/repo/docker-compose.yml"
      register: docker_compose_content
      changed_when: false

    - name: Show docker-compose.yml content
      ansible.builtin.debug:
        msg: "{{ docker_compose_content.stdout_lines }}"

    - name: Pull promoted production image from GHCR
      ansible.builtin.command: bash -c "cd {{ app_dir }}/repo && docker-compose pull web"
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_pull
      retries: 3
      delay: 10
      until: docker_pull is success
      changed_when: false

    - name: Fix Docker volume permissions for Next.js cache
      ansible.builtin.shell: |
        # Create the volume explicitly with correct name
        docker volume create next_cache 2>/dev/null || true
        
        # Fix permissions using a temporary container
        docker run --rm -v next_cache:/app/.next/cache alpine:latest sh -c '
          mkdir -p /app/.next/cache/images
          chown -R 1001:1001 /app/.next/cache
          chmod -R 755 /app/.next/cache
          echo "Permissions set successfully"
          ls -la /app/.next/cache
        '
      register: volume_permission_fix
      changed_when: true

    # STREAMLINED IMAGE VERIFICATION - Essential checks only
    - name: Verify image pull was successful
      ansible.builtin.command: |
        bash -c "
        echo '🔍 Verifying image pull was successful...'
        
        # Check that image exists locally using multiple methods
        echo 'Checking for image: {{ docker_image }}'
        
        # Extract repository and tag for flexible matching
        REPO_NAME=$(echo '{{ docker_image }}' | cut -d':' -f1)
        TAG_NAME=$(echo '{{ docker_image }}' | cut -d':' -f2)
        
        echo 'Looking for repository: \$REPO_NAME with tag: \$TAG_NAME'
        
        # Method 1: Check using docker images with custom format
        if docker images --format '{% raw %}{{.Repository}}:{{.Tag}}{% endraw %}' | grep -q '{{ docker_image }}'; then
          echo '✅ Image {{ docker_image }} found (exact format match)'
          exit 0
        fi
        
        # Method 2: Check repository and tag separately (more reliable)
        if docker images --format '{% raw %}{{.Repository}} {{.Tag}}{% endraw %}' | grep -q \"\$REPO_NAME \$TAG_NAME\"; then
          echo '✅ Image found (repository and tag match): \$REPO_NAME:\$TAG_NAME'
          exit 0
        fi
        
        # Method 3: Check just the repository name using simple docker images
        if docker images | grep -q \"\$REPO_NAME.*\$TAG_NAME\"; then
          echo '✅ Image repository found: \$REPO_NAME with tag \$TAG_NAME'
          docker images \"\$REPO_NAME\"
          exit 0
        fi
        
        # Method 4: Use docker inspect to verify image exists
        if docker inspect '{{ docker_image }}' >/dev/null 2>&1; then
          echo '✅ Image {{ docker_image }} verified via docker inspect'
          exit 0
        fi
        
        # If all methods fail, show debug info
        echo '❌ Image verification failed. Debug information:'
        echo 'Expected image: {{ docker_image }}'
        echo 'Repository: \$REPO_NAME, Tag: \$TAG_NAME'
        echo ''
        echo 'Available images:'
        docker images
        echo ''
        echo 'Docker-compose images:'
        cd {{ app_dir }}/repo && docker-compose images || true
        echo ''
        echo 'Trying docker inspect:'
        docker inspect '{{ docker_image }}' || echo 'Docker inspect failed'
        exit 1
        "
      register: image_pull_verification
      changed_when: false
      when: docker_pull is success and volume_permission_fix is success

    # STREAMLINED ENVIRONMENT VARIABLE VALIDATION - Essential checks only
    - name: Validate critical environment variables
      ansible.builtin.debug:
        msg: |
          🔍 Validating critical environment variables for production deployment
          
          Required Variables Status:
          - BREVO_API_KEY: {{ '✅ SET' if brevo_api_key else '❌ MISSING' }}
          - STRIPE_SECRET_KEY: {{ '✅ SET' if stripe_secret_key else '❌ MISSING' }}
          - STRIPE_PUBLISHABLE_KEY: {{ '✅ SET' if stripe_publishable_key else '❌ MISSING' }}
          - GA_PRODUCTION_ID: {{ '✅ SET' if ga_production_id else '❌ MISSING' }}
          - GITHUB_TOKEN: {{ '✅ SET' if github_token else '❌ MISSING' }}
          - GITHUB_USERNAME: {{ '✅ SET' if github_username else '❌ MISSING' }}
          - GIT_REPO_URL: {{ '✅ SET' if git_repo_url else '❌ MISSING' }}

    - name: Fail if critical environment variables are missing
      ansible.builtin.fail:
        msg: |
          Critical environment variables are missing!
          Please set them in your environment or GitHub Secrets.
      when: >
        not brevo_api_key or
        not stripe_secret_key or
        not stripe_publishable_key or
        not ga_production_id or
        not github_token or
        not github_username or
        not git_repo_url

    - name: Create production environment file
      ansible.builtin.copy:
        dest: "{{ app_dir }}/.env.production"
        mode: '0600'
        content: |
          NODE_ENV=production
          NEXT_PUBLIC_ENVIRONMENT=production
          NEXT_PUBLIC_API_URL=http://{{ public_ip }}/api
          BREVO_API_KEY={{ brevo_api_key }}
          STRIPE_SECRET_KEY={{ stripe_secret_key }}
          STRIPE_PUBLISHABLE_KEY={{ stripe_publishable_key }}
          GA_PRODUCTION_ID={{ ga_production_id }}
          GITHUB_TOKEN={{ github_token }}
          GITHUB_USERNAME={{ github_username }}
          DOCKER_IMAGE={{ docker_image }}
          
    # Docker services startup section
    - name: Start Docker Compose services
      command: docker-compose up -d --force-recreate --remove-orphans web
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_up
      retries: 3
      delay: 15
      until: docker_up is success
      
    - name: Check if Docker Compose services started successfully
      command: docker-compose ps
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_ps
      changed_when: false
      
    - name: Display Docker Compose status
      debug:
        var: docker_ps.stdout_lines

    # STREAMLINED VERIFICATION - Essential checks after deployment
    - name: Basic application health check
      ansible.builtin.command: |
        bash -c "
        echo '🏥 Performing basic health check...'
        
        # Wait for service to be ready
        sleep 20
        
        # Test basic connectivity
        if curl -f -s http://localhost:8080 >/dev/null 2>&1; then
          echo '✅ Application is responding'
        else
          echo '❌ Application health check failed'
          exit 1
        fi
        "
      register: basic_health_check
      changed_when: false
      when: docker_up is defined and docker_up.rc == 0

    - name: Display deployment completion message
      ansible.builtin.debug:
        msg: |
          ============================================
          PRODUCTION DEPLOYMENT COMPLETED SUCCESSFULLY
          ============================================
          
          Application is now available at http://{{ public_ip }}
          
          Deployment Details:
          - Environment: Production
          - Image Source: Image Promotion Workflow
          - Production Image: {{ docker_image }}
          - Status: Deployed and Running
          
          Image Promotion Workflow:
          - Staging → Image Promotion → Production
          - Manual approval required for promotion
          - Promoted images stored in GHCR
          
          Next Steps:
          1. Monitor application health
          2. SSL certificate setup will run next (separate play)
          3. Test production functionality
          4. For updates: Repeat staging → promotion → production cycle
          
          ============================================

    - name: Configure Nginx worker processes from template
      ansible.builtin.template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
        mode: '0644'
        backup: true

    - name: Configure Nginx as reverse proxy from template
      ansible.builtin.template:
        src: nextjs-site.conf.j2
        dest: /etc/nginx/sites-available/nextjs-app
        mode: '0644'
        backup: true

    - name: Enable Nginx site configuration
      file:
        src: /etc/nginx/sites-available/nextjs-app
        dest: /etc/nginx/sites-enabled/nextjs-app
        state: link

    - name: Remove default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      ignore_errors: yes

    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_test
      changed_when: false
      ignore_errors: true

    - name: Display Nginx test results
      debug:
        msg: "{{ nginx_test.stderr_lines }}"
      when: nginx_test.rc != 0

    - name: Restart Nginx
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_test.rc == 0
      register: nginx_restart
      retries: 2
      delay: 5
      until: nginx_restart is success

    # Basic SSL certificate status check (moved from SSL play)
    - name: Check if SSL certificate exists
      ansible.builtin.stat:
        path: /etc/letsencrypt/live/boximity.ca/cert.pem
      register: initial_ssl_cert_check

    - name: Display initial SSL certificate status
      ansible.builtin.debug:
        msg: |
          🔒 Initial SSL Certificate Status:
          
          Certificate exists: {{ '✅ YES' if initial_ssl_cert_check.stat.exists else '❌ NO' }}
          {% if initial_ssl_cert_check.stat.exists %}
          Certificate will be validated in SSL setup play.
          {% else %}
          Certificate will be obtained in SSL setup play.
          {% endif %}

    - name: Setup firewall (UFW)
      community.general.ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - 22
        - 80
        - 443
        - 6080
        - 8080
      become: true

    - name: Enable UFW
      community.general.ufw:
        state: enabled
        policy: deny
      become: true

    - name: Create enhanced monitoring script from template
      ansible.builtin.template:
        src: monitor.sh.j2
        dest: "{{ app_dir }}/monitor.sh"
        mode: '0755'
        backup: true
          
    - name: Set up monitoring cron job
      cron:
        name: "Monitor dotca-nextjs"
        minute: "*/15"
        job: "{{ app_dir }}/monitor.sh >> {{ app_dir }}/monitoring.log 2>&1"
        state: present

    # Copy additional utility templates for consistency with staging
    - name: Copy Docker cleanup script from template
      ansible.builtin.template:
        src: docker_cleanup.sh.j2
        dest: "{{ app_dir }}/docker_cleanup.sh"
        mode: '0755'
        backup: true

    - name: Copy port verification script from template
      ansible.builtin.template:
        src: port_verification.sh.j2
        dest: "{{ app_dir }}/port_verification.sh"
        mode: '0755'
        backup: true

    - name: Copy logrotate configuration from template
      ansible.builtin.template:
        src: logrotate.conf.j2
        dest: /etc/logrotate.d/dotca-production
        mode: '0644'
        backup: true

# SSL Certificate Setup using geerlingguy certbot role
- name: Setup Let's Encrypt SSL Certificates
  hosts: digitalocean
  become: yes
  vars:
    # Certbot configuration
    certbot_install_method: package
    certbot_auto_renew: true
    certbot_auto_renew_user: "{{ ansible_user | default(lookup('env', 'USER')) }}"
    certbot_auto_renew_hour: "3"
    certbot_auto_renew_minute: "30"
    certbot_auto_renew_options: "--quiet"
    
    # Certificate generation settings - only create if needed
    certbot_create_if_missing: "{{ cert_needs_action | default(true) }}"
    certbot_create_method: standalone
    certbot_testmode: false
    certbot_hsts: true
    certbot_admin_email: "matticem@boximity.ca"
    
    # Domain configuration
    certbot_certs:
      - domains:
          - boximity.ca
          - www.boximity.ca
        email: "matticem@boximity.ca"
    
    # Services to stop during standalone certificate generation
    certbot_create_standalone_stop_services:
      - nginx
  
  pre_tasks:
    - name: Ensure domain is configured in Nginx before certificate generation
      ansible.builtin.replace:
        path: /etc/nginx/sites-available/nextjs-app
        regexp: 'server_name _;'
        replace: 'server_name boximity.ca www.boximity.ca;'
      register: nginx_domain_update
      ignore_errors: yes

    - name: Restart Nginx if domain configuration was updated
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_domain_update is changed

    # Certificate existence and expiration checking
    - name: Check if SSL certificate already exists
      stat:
        path: /etc/letsencrypt/live/boximity.ca/cert.pem
      register: cert_file_exists

    - name: Get certificate expiration date if it exists
      ansible.builtin.shell: |
        openssl x509 -in /etc/letsencrypt/live/boximity.ca/cert.pem -noout -enddate | cut -d= -f2
      register: cert_expiry_raw
      changed_when: false
      failed_when: false
      when: cert_file_exists.stat.exists

    - name: Check if certificate needs renewal
      ansible.builtin.shell: |
        CERT_EXPIRY="{{ cert_expiry_raw.stdout | default('') }}"
        if [ -n "$CERT_EXPIRY" ]; then
          CERT_EXPIRY_EPOCH=$(date -d "$CERT_EXPIRY" +%s)
          RENEWAL_THRESHOLD=$(date -d '+30 days' +%s)
          if [ $CERT_EXPIRY_EPOCH -lt $RENEWAL_THRESHOLD ]; then
            echo "renewal_needed"
          else
            echo "certificate_valid"
          fi
        else
          echo "certificate_missing"
        fi
      register: cert_renewal_status
      changed_when: false
      failed_when: false

    - name: Display certificate status
      ansible.builtin.debug:
        msg: |
          📋 SSL Certificate Status Check:

          Certificate exists: {{ '✅ YES' if cert_file_exists.stat.exists else '❌ NO' }}
          {% if cert_file_exists.stat.exists %}
          Certificate expiry: {{ cert_expiry_raw.stdout | default('Could not determine') }}
          Status: {{ '✅ VALID' if cert_renewal_status.stdout == 'certificate_valid' else '⚠️  NEEDS RENEWAL' if cert_renewal_status.stdout == 'renewal_needed' else '❓ UNKNOWN' }}
          {% endif %}

          Action needed: {{ 'None - certificate is valid' if cert_renewal_status.stdout == 'certificate_valid' else 'Certificate creation/renewal required' }}

    - name: Set certificate action flag
      ansible.builtin.set_fact:
        cert_needs_action: "{{ not cert_file_exists.stat.exists or cert_renewal_status.stdout == 'renewal_needed' }}"

  roles:
    - geerlingguy.certbot

  post_tasks:
    - name: Display certificate action taken
      ansible.builtin.debug:
        msg: |
          🔍 SSL Certificate Action Summary:
          
          Action was needed: {{ '✅ YES' if cert_needs_action else '❌ NO' }}
          {% if cert_needs_action %}
          - Certificate was {{ 'missing' if not cert_file_exists.stat.exists else 'expiring soon' }}
          - Certbot role was executed to {{ 'create' if not cert_file_exists.stat.exists else 'renew' }} certificate
          {% else %}
          - Existing certificate is valid and not expiring soon
          - No certificate action was required
          {% endif %}

    - name: Check if SSL certificate was created successfully
      ansible.builtin.stat:
        path: /etc/letsencrypt/live/boximity.ca/cert.pem
      register: final_ssl_cert_check

    - name: Get final certificate expiration date
      ansible.builtin.shell: |
        openssl x509 -in /etc/letsencrypt/live/boximity.ca/cert.pem -noout -enddate | cut -d= -f2
      register: final_cert_expiry
      when: final_ssl_cert_check.stat.exists
      changed_when: false

    - name: Test HTTPS connectivity
      ansible.builtin.uri:
        url: https://localhost
        method: GET
        validate_certs: false
        timeout: 10
      register: https_test
      failed_when: false
      when: final_ssl_cert_check.stat.exists

    - name: Display final SSL certificate verification
      ansible.builtin.debug:
        msg: |
          🔒 Final SSL Certificate Verification:
          
          Certificate exists: {{ '✅ YES' if final_ssl_cert_check.stat.exists else '❌ NO' }}
          {% if final_ssl_cert_check.stat.exists %}
          Certificate expires: {{ final_cert_expiry.stdout | default('Could not determine') }}
          HTTPS connectivity: {{ '✅ Working' if https_test.status is defined and https_test.status == 200 else '⚠️  May need Nginx restart' }}
          {% endif %}
          
          Status: {{ '✅ SSL setup completed successfully' if final_ssl_cert_check.stat.exists else '❌ SSL setup failed' }}

    - name: Fail if SSL certificate verification failed
      ansible.builtin.fail:
        msg: "SSL certificate verification failed - certificate not found"
      when: not final_ssl_cert_check.stat.exists

    - name: Restart Nginx after SSL certificate setup
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: ssl_certificate_verification.rc == 0

    - name: Final SSL certificate status
      ansible.builtin.debug:
        msg: |
          ============================================
          INTELLIGENT SSL CERTIFICATE SETUP COMPLETED
          ============================================
          
          Domain: boximity.ca
          Status: {{ '✅ SUCCESS' if ssl_certificate_verification.rc == 0 else '❌ FAILED' }}
          Action Taken: {{ 'Certificate created/renewed' if cert_needs_action else 'No action needed - existing certificate is valid' }}
          
          Certificate Details:
          - Location: /etc/letsencrypt/live/boximity.ca/
          - Auto-renewal: Enabled (daily at 3:30 AM)
          - Renewal threshold: 30 days before expiration
          
          Smart Features:
          ✅ Only creates certificates when needed (missing or expiring < 30 days)
          ✅ Checks existing certificate validity before taking action
          ✅ Provides detailed expiration information
          ✅ Automatic renewal with cron job
          
          Next Steps:
          1. Test HTTPS access: https://boximity.ca
          2. Monitor certificate expiration (automated)
          3. Verify auto-renewal is working (runs daily at 3:30 AM)
          
          ============================================
