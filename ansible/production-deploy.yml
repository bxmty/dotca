---
# Ansible playbook for setting up the Production environment for dotca
# With optimizations for Next.js deployment

# Add a pre-task to fix temporary directory issues
- name: Fix temporary directory issues
  hosts: digitalocean
  become: true
  gather_facts: false
  tasks:
    - name: Ensure /tmp directory exists with proper permissions
      ansible.builtin.raw: |
        mkdir -p /tmp
        chmod 1777 /tmp
        df -h /tmp

- name: Setup Production environment for dotca
  hosts: digitalocean
  become: true
  vars:
    project_name: dotca-nextjs
    git_repo_url: "{{ lookup('env', 'GIT_REPO_URL') }}"
    git_branch: main
    app_dir: /app
    public_ip: "{{ ansible_host }}"
    brevo_api_key: "{{ lookup('env', 'BREVO_API_KEY') }}"
    stripe_secret_key: "{{ lookup('env', 'STRIPE_SECRET_KEY') }}"
    stripe_publishable_key: "{{ lookup('env', 'STRIPE_PUBLISHABLE_KEY') }}"
    ga_production_id: "{{ lookup('env', 'GA_PRODUCTION_ID') }}"
    docker_compose_file: "{{ app_dir }}/repo/docker-compose.yml"
    # GitHub Container Registry settings for promoted images
    github_token: "{{ lookup('env', 'GITHUB_TOKEN') }}"
    github_username: "{{ lookup('env', 'GITHUB_USERNAME') }}"
    # Production image configuration - uses promoted images from GHCR
    docker_image_override: "{{ lookup('env', 'DOCKER_IMAGE') }}"
    github_repo_from_url: "{{ git_repo_url | regex_replace('.*github\\.com[/:]([^/]+/[^/.]+).*', '\\1') if git_repo_url else '' }}"
    # Default to main tag (promoted production image)
    docker_image: >-
      {{
        docker_image_override if docker_image_override else 
        ('ghcr.io/' + github_repo_from_url + ':main') if github_repo_from_url else
        'ghcr.io/bxtech/dotca:main'
      }}

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Upgrade all packages
      apt:
        upgrade: yes

    - name: Install required packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - git
          - python3-pip
          - jq
          - nginx
          - docker-compose
        state: present
        update_cache: yes

    - name: Add Docker's official GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        update_cache: yes

    - name: Install Docker Engine
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
        update_cache: yes
      register: docker_install_result
      retries: 3
      delay: 5
      until: docker_install_result is success

    - name: Install NTP for time synchronization
      apt:
        name: ntp
        state: present
        update_cache: yes

    - name: Configure NTP to use time.nist.gov
      lineinfile:
        path: /etc/ntp.conf
        regexp: '^server'
        line: 'server time.nist.gov iburst'
        state: present
        backup: yes

    - name: Restart NTP service
      systemd:
        name: ntp
        state: restarted
        enabled: yes

    - name: Set timezone to Eastern Time
      timezone:
        name: America/New_York

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
      register: docker_service_result
      retries: 3
      delay: 5
      until: docker_service_result is success

    - name: Verify Docker Compose installation
      command: docker-compose --version
      register: compose_version
      changed_when: false

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Clone the repository
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
      register: git_clone
      retries: 3
      delay: 10
      until: git_clone is success

    - name: Verify Next.js configuration file
      stat:
        path: "{{ app_dir }}/repo/next.config.js"
      register: next_config

    - name: Fail if Next.js configuration is missing
      fail:
        msg: "Missing Next.js configuration file. Please ensure next.config.js exists in the repository."
      when: not next_config.stat.exists

    # DEPLOYMENT TASKS START HERE
    - name: Pull latest changes from git
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
        update: yes
      register: git_pull
      retries: 3
      delay: 5
      until: git_pull is success

    - name: Generate docker-compose.yml from template
      ansible.builtin.template:
        src: docker-compose.yml.j2
        dest: "{{ app_dir }}/repo/docker-compose.yml"
        mode: '0644'
        backup: true
      vars:
        node_env: production
        next_public_api_url: "http://{{ public_ip }}/api"
        next_public_environment: production
        brevo_api_key: "{{ brevo_api_key }}"
        stripe_secret_key: "{{ stripe_secret_key }}"
        stripe_publishable_key: "{{ stripe_publishable_key }}"
        ga_production_id: "{{ ga_production_id }}"

    - name: Display generated docker-compose.yml for debugging
      ansible.builtin.command: cat "{{ app_dir }}/repo/docker-compose.yml"
      register: docker_compose_content
      changed_when: false

    - name: Show docker-compose.yml content
      ansible.builtin.debug:
        msg: "{{ docker_compose_content.stdout_lines }}"

    - name: Stop existing Docker Compose services
      command: docker-compose down web
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_down_result
      ignore_errors: yes

    - name: Stop any other containers using port 8080
      shell: |
        if docker ps -q --filter publish=8080 | grep -q .; then
          docker stop $(docker ps -q --filter publish=8080)
        fi
      ignore_errors: yes

    - name: Prune Docker system
      command: docker system prune -af

    - name: Login to GitHub Container Registry
      ansible.builtin.command: bash -c 'set -o pipefail && echo "{{ github_token }}" | docker login ghcr.io -u {{ github_username }} --password-stdin'
      when: github_token is defined and github_username is defined
      register: docker_login
      retries: 3
      delay: 5
      until: docker_login is success
      changed_when: false

    - name: Verify promoted production image exists in GHCR
      ansible.builtin.command: |
        bash -c "
        if [ -z '{{ docker_image | default('') }}' ]; then 
          echo 'ERROR: docker_image variable is empty or undefined'
          exit 1
        fi
        echo 'Checking if promoted production image exists: {{ docker_image }}'
        docker manifest inspect '{{ docker_image }}'
        "
      register: production_image_exists
      ignore_errors: true
      changed_when: false
      when: docker_image is defined and docker_image != ""

    - name: Set image_exists to failed state if docker_image is empty
      ansible.builtin.set_fact:
        production_image_exists:
          rc: 1
          stdout: ""
          stderr: "docker_image variable is empty or undefined"
      when: docker_image is not defined or docker_image == ""

    - name: Try alternative production image names if primary fails
      ansible.builtin.command: |
        bash -c "echo \"Trying alternative production image: ghcr.io/{{ github_username }}/dotca:main\"; docker manifest inspect \"ghcr.io/{{ github_username }}/dotca:main\""
      register: alt_production_image_exists
      ignore_errors: true
      changed_when: false
      when: (production_image_exists.rc | default(1) != 0) and github_username

    - name: Set production image availability status variables
      ansible.builtin.set_fact:
        primary_production_image_status: "{{ 'YES' if (production_image_exists.rc | default(1) == 0) else 'NO' }}"
        alt_production_image_status: "{{ 'YES' if (alt_production_image_exists.rc | default(1) == 0) else 'NO' }}"
        any_production_image_found: "{{ (production_image_exists.rc | default(1) == 0) or (alt_production_image_exists.rc | default(1) == 0) }}"

    - name: Display production image availability
      ansible.builtin.debug:
        msg: 
          - "Production image {{ docker_image }} exists: {{ primary_production_image_status }}"
          - "Alternative production image exists: {{ alt_production_image_status }}"
          - ""
          - "{{ 'SUCCESS: Found promoted production image!' if any_production_image_found else 'ERROR: No promoted production images found!' }}"
          - ""
          - "If no images found, check:"
          - "1. Has the image promotion workflow completed? Check: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml"
          - "2. Was the promotion approved in the GitHub environment?"
          - "3. Does the image name match what was created by the promotion workflow?"
          - "4. Are you authenticated to GHCR properly?"

    - name: Use alternative production image if primary failed
      ansible.builtin.set_fact:
        docker_image: "ghcr.io/{{ github_username }}/dotca:main"
      when: (production_image_exists is defined and production_image_exists.rc != 0) and alt_production_image_exists is defined and alt_production_image_exists.rc == 0

    - name: Fail if no promoted production images found
      ansible.builtin.fail:
        msg: |
          No promoted production images found in GHCR! 
          
          This means the image promotion workflow hasn't completed yet or failed.
          
          Steps to fix:
          1. Check image promotion workflow: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml
          2. Ensure staging deployment completed successfully
          3. Trigger and approve the image promotion workflow
          4. Verify the promoted image exists in GHCR
          
          Expected image locations:
          - {{ docker_image }}
          - ghcr.io/{{ github_username }}/dotca:main (if username available)
          
          Current workflow status:
          - Staging deployment: Check staging-deploy.yml workflow
          - Image promotion: Check image-promotion.yml workflow
          - Production deployment: This workflow (requires promoted image)
      when: not any_production_image_found

    - name: Pull promoted production image from GHCR
      ansible.builtin.command: bash -c "cd {{ app_dir }}/repo && docker-compose pull web"
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_pull
      retries: 3
      delay: 10
      until: docker_pull is success
      changed_when: false

    - name: Verify promoted image integrity
      ansible.builtin.command: |
        bash -c "
        echo 'Verifying promoted production image integrity...'
        cd {{ app_dir }}/repo
        
        # Get image details
        IMAGE_ID=\$(docker images --format '{{.ID}}' {{ docker_image }} | head -1)
        IMAGE_SIZE=\$(docker images --format '{{.Size}}' {{ docker_image }} | head -1)
        IMAGE_CREATED=\$(docker images --format '{{.CreatedAt}}' {{ docker_image }} | head -1)
        
        echo 'Production Image Details:'
        echo '  - Image: {{ docker_image }}'
        echo '  - ID: \$IMAGE_ID'
        echo '  - Size: \$IMAGE_SIZE'
        echo '  - Created: \$IMAGE_CREATED'
        
        # Verify image can run
        echo 'Testing image startup...'
        if docker run --rm {{ docker_image }} --help >/dev/null 2>&1; then
          echo '✅ Image integrity verified - can start container'
        else
          echo '⚠️  Image startup test failed, but continuing...'
        fi
        
        # Check for required labels
        echo 'Checking image labels...'
        docker inspect {{ docker_image }} | jq -r '.[0].Config.Labels // {}' | grep -E '(org.opencontainers|version|source)' || echo 'No OCI labels found'
        "
      register: image_integrity_check
      changed_when: false
      when: docker_pull is success

    - name: Start Docker Compose services
      command: docker-compose up -d web
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_up
      retries: 3
      delay: 15
      until: docker_up is success
      
    - name: Check if Docker Compose services started successfully
      command: docker-compose ps
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_ps
      changed_when: false
      
    - name: Display Docker Compose status
      debug:
        var: docker_ps.stdout_lines
      
    - name: Display deployment completion message
      ansible.builtin.debug:
        msg: |
          ============================================
          PRODUCTION DEPLOYMENT COMPLETED SUCCESSFULLY
          ============================================
          
          Application is now available at http://{{ public_ip }}
          
          Deployment Details:
          - Environment: Production
          - Image Source: Image Promotion Workflow
          - Production Image: {{ docker_image }}
          - Status: Deployed and Running
          
          Image Promotion Workflow:
          - Staging → Image Promotion → Production
          - Manual approval required for promotion
          - Promoted images stored in GHCR
          
          Next Steps:
          1. Monitor application health
          2. Verify SSL certificate (if applicable)
          3. Test production functionality
          4. For updates: Repeat staging → promotion → production cycle
          
          ============================================

    - name: Configure Nginx worker processes from template
      ansible.builtin.template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
        mode: '0644'
        backup: true

    - name: Configure Nginx as reverse proxy from template
      ansible.builtin.template:
        src: nextjs-site.conf.j2
        dest: /etc/nginx/sites-available/nextjs-app
        mode: '0644'
        backup: true

    - name: Enable Nginx site configuration
      file:
        src: /etc/nginx/sites-available/nextjs-app
        dest: /etc/nginx/sites-enabled/nextjs-app
        state: link

    - name: Remove default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      ignore_errors: yes

    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_test
      changed_when: false
      ignore_errors: true

    - name: Display Nginx test results
      debug:
        msg: "{{ nginx_test.stderr_lines }}"
      when: nginx_test.rc != 0

    - name: Restart Nginx
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_test.rc == 0
      register: nginx_restart
      retries: 2
      delay: 5
      until: nginx_restart is success

    - name: Setup firewall (UFW)
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - '22'
        - '80'
        - '443'
        - '6080'
        - '8080'

    - name: Enable UFW
      ufw:
        state: enabled
        policy: deny

    - name: Create enhanced monitoring script from template
      ansible.builtin.template:
        src: monitor.sh.j2
        dest: "{{ app_dir }}/monitor.sh"
        mode: '0755'
        backup: true
          
    - name: Set up monitoring cron job
      cron:
        name: "Monitor dotca-nextjs"
        minute: "*/15"
        job: "{{ app_dir }}/monitor.sh >> {{ app_dir }}/monitoring.log 2>&1"
        state: present

    # Copy additional utility templates for consistency with staging
    - name: Copy Docker cleanup script from template
      ansible.builtin.template:
        src: docker_cleanup.sh.j2
        dest: "{{ app_dir }}/docker_cleanup.sh"
        mode: '0755'
        backup: true

    - name: Copy port verification script from template
      ansible.builtin.template:
        src: port_verification.sh.j2
        dest: "{{ app_dir }}/port_verification.sh"
        mode: '0755'
        backup: true

    - name: Copy logrotate configuration from template
      ansible.builtin.template:
        src: logrotate.conf.j2
        dest: /etc/logrotate.d/dotca-production
        mode: '0644'
        backup: true

# Create a separate play for Let's Encrypt setup
- name: Setup Let's Encrypt with Nginx
  hosts: digitalocean
  become: yes
  vars:
    domain_name: "boximity.ca"
    email_address: "matticem@boximity.ca"
  
  tasks:
    - name: Install Certbot and Nginx plugin
      package:
        name:
          - certbot
          - python3-certbot-nginx
        state: present
      register: certbot_install
      retries: 3
      delay: 5
      until: certbot_install is success

    - name: Check if certificate already exists
      stat:
        path: /etc/letsencrypt/live/{{ domain_name }}/cert.pem
      register: cert_file

    # Check if domain is properly configured in Nginx before requesting a certificate
    - name: Verify domain configuration in Nginx
      ansible.builtin.shell: |
        if [ -f /etc/nginx/sites-available/nextjs-app ]; then
          grep -q "server_name {{ domain_name }}" /etc/nginx/sites-available/nextjs-app || echo "Domain not configured"
        else
          echo "Nginx config not found"
        fi
      register: domain_check
      changed_when: false

    - name: Configure domain in Nginx if needed
      ansible.builtin.replace:
        path: /etc/nginx/sites-available/nextjs-app
        regexp: 'server_name _;'
        replace: 'server_name {{ domain_name }};'
      when: domain_check.stdout == "Domain not configured" or domain_check.stdout == "Nginx config not found"
      register: nginx_domain_update

    - name: Restart Nginx before certificate request
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_domain_update is changed

    # Verify Nginx is responding with the correct domain before obtaining certificate
    - name: Verify Nginx is serving the domain correctly
      ansible.builtin.uri:
        url: http://localhost
        method: GET
        return_content: yes
      register: nginx_check
      ignore_errors: yes

    - name: Debug Nginx response
      debug:
        msg: "Nginx Health Check: {{ nginx_check.status | default('Failed') }}"

    - name: Obtain SSL certificate
      command: >
        certbot --nginx -d {{ domain_name }}
        --non-interactive --agree-tos 
        --email {{ email_address }}
        --redirect
      when: not cert_file.stat.exists and (nginx_check.status | default(0)) == 200
      register: certbot_result
      retries: 2
      delay: 30
      until: certbot_result is success
      
    - name: Log certificate generation results
      debug:
        msg: "Certbot output: {{ certbot_result.stdout_lines | default(['No output']) }}"
      when: not cert_file.stat.exists and certbot_result is defined

    - name: Add cron job for auto-renewal
      cron:
        name: "Let's Encrypt renewal"
        special_time: daily
        job: "certbot renew --quiet --nginx"