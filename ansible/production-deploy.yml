---
# Ansible playbook for setting up the Production environment for dotca
# With optimizations for Next.js deployment

# Add a pre-task to fix temporary directory issues
- name: Fix temporary directory issues
  hosts: digitalocean
  become: true
  gather_facts: false
  tasks:
    - name: Ensure /tmp directory exists with proper permissions
      ansible.builtin.raw: |
        mkdir -p /tmp
        chmod 1777 /tmp
        df -h /tmp

- name: Setup Production environment for dotca
  hosts: digitalocean
  become: true
  vars:
    project_name: dotca-nextjs
    git_repo_url: "{{ lookup('env', 'GIT_REPO_URL') }}"
    git_branch: main
    app_dir: /app
    public_ip: "{{ ansible_host }}"
    brevo_api_key: "{{ lookup('env', 'BREVO_API_KEY') }}"
    stripe_secret_key: "{{ lookup('env', 'STRIPE_SECRET_KEY') }}"
    stripe_publishable_key: "{{ lookup('env', 'STRIPE_PUBLISHABLE_KEY') }}"
    ga_production_id: "{{ lookup('env', 'GA_PRODUCTION_ID') }}"
    docker_compose_file: "{{ app_dir }}/repo/docker-compose.yml"
    # GitHub Container Registry settings for promoted images
    github_token: "{{ lookup('env', 'GITHUB_TOKEN') }}"
    github_username: "{{ lookup('env', 'GITHUB_USERNAME') }}"
    # Production image configuration - uses promoted images from GHCR
    docker_image_override: "{{ lookup('env', 'DOCKER_IMAGE') }}"
    github_repo_from_url: "{{ git_repo_url | regex_replace('.*github\\.com[/:]([^/]+/[^/.]+).*', '\\1') if git_repo_url else '' }}"
    # Default to main tag (promoted production image)
    docker_image: >-
      {{
        docker_image_override if docker_image_override else 
        ('ghcr.io/' + github_repo_from_url + ':main') if github_repo_from_url else
        'ghcr.io/bxtech/dotca:main'
      }}

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Upgrade all packages
      apt:
        upgrade: yes

    - name: Install required packages
      apt:
        name:
          - apt-transport-https
          - ca-certificates
          - curl
          - gnupg
          - lsb-release
          - git
          - python3-pip
          - jq
          - nginx
          - docker-compose
        state: present
        update_cache: yes

    - name: Add Docker's official GPG key
      apt_key:
        url: https://download.docker.com/linux/ubuntu/gpg
        state: present

    - name: Add Docker repository
      apt_repository:
        repo: "deb [arch=amd64] https://download.docker.com/linux/ubuntu {{ ansible_distribution_release }} stable"
        state: present
        update_cache: yes

    - name: Install Docker Engine
      apt:
        name:
          - docker-ce
          - docker-ce-cli
          - containerd.io
        state: present
        update_cache: yes
      register: docker_install_result
      retries: 3
      delay: 5
      until: docker_install_result is success

    - name: Install NTP for time synchronization
      apt:
        name: ntp
        state: present
        update_cache: yes

    - name: Configure NTP to use time.nist.gov
      lineinfile:
        path: /etc/ntp.conf
        regexp: '^server'
        line: 'server time.nist.gov iburst'
        state: present
        backup: yes

    - name: Restart NTP service
      systemd:
        name: ntp
        state: restarted
        enabled: yes

    - name: Set timezone to Eastern Time
      timezone:
        name: America/New_York

    - name: Start and enable Docker service
      systemd:
        name: docker
        state: started
        enabled: yes
      register: docker_service_result
      retries: 3
      delay: 5
      until: docker_service_result is success

    - name: Verify Docker Compose installation
      command: docker-compose --version
      register: compose_version
      changed_when: false

    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        mode: '0755'

    - name: Clone the repository
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
      register: git_clone
      retries: 3
      delay: 10
      until: git_clone is success

    - name: Verify Next.js configuration file
      stat:
        path: "{{ app_dir }}/repo/next.config.js"
      register: next_config

    - name: Fail if Next.js configuration is missing
      fail:
        msg: "Missing Next.js configuration file. Please ensure next.config.js exists in the repository."
      when: not next_config.stat.exists

    # DEPLOYMENT TASKS START HERE
    - name: Pull latest changes from git
      git:
        repo: "{{ git_repo_url }}"
        dest: "{{ app_dir }}/repo"
        version: "{{ git_branch }}"
        force: yes
        update: yes
      register: git_pull
      retries: 3
      delay: 5
      until: git_pull is success

    - name: Generate docker-compose.yml from template
      ansible.builtin.template:
        src: docker-compose.yml.j2
        dest: "{{ app_dir }}/repo/docker-compose.yml"
        mode: '0644'
        backup: true
      vars:
        node_env: production
        next_public_api_url: "http://{{ public_ip }}/api"
        next_public_environment: production
        brevo_api_key: "{{ brevo_api_key }}"
        stripe_secret_key: "{{ stripe_secret_key }}"
        stripe_publishable_key: "{{ stripe_publishable_key }}"
        ga_production_id: "{{ ga_production_id }}"

    - name: Display generated docker-compose.yml for debugging
      ansible.builtin.command: cat "{{ app_dir }}/repo/docker-compose.yml"
      register: docker_compose_content
      changed_when: false

    - name: Show docker-compose.yml content
      ansible.builtin.debug:
        msg: "{{ docker_compose_content.stdout_lines }}"

    - name: Stop existing Docker Compose services
      command: docker-compose down web
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_down_result
      ignore_errors: yes

    - name: Stop any other containers using port 8080
      shell: |
        if docker ps -q --filter publish=8080 | grep -q .; then
          docker stop $(docker ps -q --filter publish=8080)
        fi
      ignore_errors: yes

    - name: Prune Docker system
      command: docker system prune -af

    - name: Login to GitHub Container Registry
      ansible.builtin.command: bash -c 'set -o pipefail && echo "{{ github_token }}" | docker login ghcr.io -u {{ github_username }} --password-stdin'
      when: github_token is defined and github_username is defined
      register: docker_login
      retries: 3
      delay: 5
      until: docker_login is success
      changed_when: false

    - name: Verify promoted production image exists in GHCR
      ansible.builtin.command: |
        bash -c "
        if [ -z '{{ docker_image | default('') }}' ]; then 
          echo 'ERROR: docker_image variable is empty or undefined'
          exit 1
        fi
        echo 'Checking if promoted production image exists: {{ docker_image }}'
        docker manifest inspect '{{ docker_image }}'
        "
      register: production_image_exists
      ignore_errors: true
      changed_when: false
      when: docker_image is defined and docker_image != ""

    - name: Set image_exists to failed state if docker_image is empty
      ansible.builtin.set_fact:
        production_image_exists:
          rc: 1
          stdout: ""
          stderr: "docker_image variable is empty or undefined"
      when: docker_image is not defined or docker_image == ""

    - name: Try alternative production image names if primary fails
      ansible.builtin.command: |
        bash -c "echo \"Trying alternative production image: ghcr.io/{{ github_username }}/dotca:main\"; docker manifest inspect \"ghcr.io/{{ github_username }}/dotca:main\""
      register: alt_production_image_exists
      ignore_errors: true
      changed_when: false
      when: (production_image_exists.rc | default(1) != 0) and github_username

    - name: Set production image availability status variables
      ansible.builtin.set_fact:
        primary_production_image_status: "{{ 'YES' if (production_image_exists.rc | default(1) == 0) else 'NO' }}"
        alt_production_image_status: "{{ 'YES' if (alt_production_image_exists.rc | default(1) == 0) else 'NO' }}"
        any_production_image_found: "{{ (production_image_exists.rc | default(1) == 0) or (alt_production_image_exists.rc | default(1) == 0) }}"

    - name: Display production image availability
      ansible.builtin.debug:
        msg: 
          - "Production image {{ docker_image }} exists: {{ primary_production_image_status }}"
          - "Alternative production image exists: {{ alt_production_image_status }}"
          - ""
          - "{{ 'SUCCESS: Found promoted production image!' if any_production_image_found else 'ERROR: No promoted production images found!' }}"
          - ""
          - "If no images found, check:"
          - "1. Has the image promotion workflow completed? Check: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml"
          - "2. Was the promotion approved in the GitHub environment?"
          - "3. Does the image name match what was created by the promotion workflow?"
          - "4. Are you authenticated to GHCR properly?"

    - name: Use alternative production image if primary failed
      ansible.builtin.set_fact:
        docker_image: "ghcr.io/{{ github_username }}/dotca:main"
      when: (production_image_exists is defined and production_image_exists.rc != 0) and alt_production_image_exists is defined and alt_production_image_exists.rc == 0

    - name: Fail if no promoted production images found
      ansible.builtin.fail:
        msg: |
          No promoted production images found in GHCR! 
          
          This means the image promotion workflow hasn't completed yet or failed.
          
          Steps to fix:
          1. Check image promotion workflow: https://github.com/{{ github_repo_from_url }}/actions/workflows/image-promotion.yml
          2. Ensure staging deployment completed successfully
          3. Trigger and approve the image promotion workflow
          4. Verify the promoted image exists in GHCR
          
          Expected image locations:
          - {{ docker_image }}
          - ghcr.io/{{ github_username }}/dotca:main (if username available)
          
          Current workflow status:
          - Staging deployment: Check staging-deploy.yml workflow
          - Image promotion: Check image-promotion.yml workflow
          - Production deployment: This workflow (requires promoted image)
      when: not any_production_image_found

    - name: Pull promoted production image from GHCR
      ansible.builtin.command: bash -c "cd {{ app_dir }}/repo && docker-compose pull web"
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_pull
      retries: 3
      delay: 10
      until: docker_pull is success
      changed_when: false

    - name: Verify promoted image integrity
      ansible.builtin.command: |
        bash -c "
        echo 'Verifying promoted production image integrity...'
        cd {{ app_dir }}/repo
        
        # Get image details
        IMAGE_ID=\$(docker images --format '{{.ID}}' {{ docker_image }} | head -1)
        IMAGE_SIZE=\$(docker images --format '{{.Size}}' {{ docker_image }} | head -1)
        IMAGE_CREATED=\$(docker images --format '{{.CreatedAt}}' {{ docker_image }} | head -1)
        
        echo 'Production Image Details:'
        echo '  - Image: {{ docker_image }}'
        echo '  - ID: \$IMAGE_ID'
        echo '  - Size: \$IMAGE_SIZE'
        echo '  - Created: \$IMAGE_CREATED'
        
        # Verify image can run
        echo 'Testing image startup...'
        if docker run --rm {{ docker_image }} --help >/dev/null 2>&1; then
          echo '‚úÖ Image integrity verified - can start container'
        else
          echo '‚ö†Ô∏è  Image startup test failed, but continuing...'
        fi
        
        # Check for required labels
        echo 'Checking image labels...'
        docker inspect {{ docker_image }} | jq -r '.[0].Config.Labels // {}' | grep -E '(org.opencontainers|version|source)' || echo 'No OCI labels found'
        "
      register: image_integrity_check
      changed_when: false
      when: docker_pull is success

    # Enhanced image verification tasks
    - name: Verify image layer count and size
      ansible.builtin.command: |
        bash -c "
        echo 'üîç Verifying image layers and size...'
        
        # Get layer information
        LAYER_COUNT=\$(docker history {{ docker_image }} | wc -l)
        TOTAL_SIZE=\$(docker images {{ docker_image }} --format '{{.Size}}' | head -1)
        
        echo 'Layer Analysis:'
        echo '  - Total Layers: \$LAYER_COUNT'
        echo '  - Total Size: \$TOTAL_SIZE'
        
        # Check for reasonable layer count (should be < 50 for optimized images)
        if [ \$LAYER_COUNT -lt 50 ]; then
          echo '‚úÖ Layer count is reasonable (\$LAYER_COUNT < 50)'
        else
          echo '‚ö†Ô∏è  High layer count (\$LAYER_COUNT) - consider image optimization'
        fi
        
        # Check for reasonable size (should be < 2GB for typical web apps)
        SIZE_NUM=\$(echo \$TOTAL_SIZE | sed 's/[^0-9.]//g')
        if [ \$(echo '\$SIZE_NUM < 2.0' | bc -l 2>/dev/null || echo '1') = '1' ]; then
          echo '‚úÖ Image size is reasonable (\$TOTAL_SIZE)'
        else
          echo '‚ö†Ô∏è  Large image size (\$TOTAL_SIZE) - consider optimization'
        fi
        "
      register: image_layer_check
      changed_when: false
      when: image_integrity_check is defined

    - name: Verify image security and vulnerability status
      ansible.builtin.command: |
        bash -c "
        echo 'üîí Checking image security...'
        
        # Check if trivy is available
        if command -v trivy >/dev/null 2>&1; then
          echo 'Running Trivy vulnerability scan...'
          trivy image --severity HIGH,CRITICAL {{ docker_image }} --format json | jq -r '.Results[].Vulnerabilities[] | select(.Severity == \"HIGH\" or .Severity == \"CRITICAL\") | .VulnerabilityID + \" (\" + .Severity + \")\"' 2>/dev/null || echo 'No high/critical vulnerabilities found'
        else
          echo '‚ö†Ô∏è  Trivy not available - skipping vulnerability scan'
          echo 'Install with: sudo apt-get install wget apt-transport-https gnupg lsb-release && wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add - && echo deb https://aquasecurity.github.io/trivy-repo/deb \$(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list && sudo apt-get update && sudo apt-get install trivy'
        fi
        
        # Check for known malicious patterns in image history
        echo 'Checking image history for suspicious patterns...'
        docker history {{ docker_image }} | grep -i -E '(curl|wget|bash -c|eval|base64)' | head -5 || echo 'No suspicious patterns found in image history'
        "
      register: image_security_check
      changed_when: false
      when: image_integrity_check is defined

    - name: Verify image configuration and health checks
      ansible.builtin.command: |
        bash -c "
        echo '‚öôÔ∏è  Verifying image configuration...'
        
        # Check if image has health check configured
        HEALTH_CHECK=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.Healthcheck // \"No health check configured\"')
        echo 'Health Check Configuration:'
        echo \$HEALTH_CHECK
        
        # Check exposed ports
        EXPOSED_PORTS=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.ExposedPorts // {}' | jq -r 'keys[]' 2>/dev/null || echo 'No ports exposed')
        echo 'Exposed Ports:'
        echo \$EXPOSED_PORTS
        
        # Check environment variables
        ENV_COUNT=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.Env // []' | jq 'length')
        echo 'Environment Variables Count: \$ENV_COUNT'
        
        # Check working directory
        WORKING_DIR=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.WorkingDir // \"Not set\"')
        echo 'Working Directory: \$WORKING_DIR'
        
        # Check entrypoint and command
        ENTRYPOINT=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.Entrypoint // []' | jq -r 'join(\" \")' 2>/dev/null || echo 'Not set')
        CMD=\$(docker inspect {{ docker_image }} | jq -r '.[0].Config.Cmd // []' | jq -r 'join(\" \")' 2>/dev/null || echo 'Not set')
        echo 'Entrypoint: \$ENTRYPOINT'
        echo 'Command: \$CMD'
        "
      register: image_config_check
      changed_when: false
      when: image_integrity_check is defined

    - name: Verify image compatibility with production environment
      ansible.builtin.command: |
        bash -c "
        echo 'üåê Verifying production environment compatibility...'
        
        # Test container startup with production-like environment
        echo 'Testing container startup with production environment variables...'
        
        # Create temporary test container
        TEST_CONTAINER=\$(docker run -d --rm \
          -e NODE_ENV=production \
          -e NEXT_PUBLIC_ENVIRONMENT=production \
          -p 3001:3000 \
          {{ docker_image }})
        
        if [ \$? -eq 0 ]; then
          echo '‚úÖ Container started successfully in production mode'
          
          # Wait for container to be ready
          sleep 10
          
          # Test health endpoint
          if curl -f -s http://localhost:3001/health >/dev/null 2>&1; then
            echo '‚úÖ Health endpoint accessible'
          else
            echo '‚ö†Ô∏è  Health endpoint not accessible'
          fi
          
          # Test basic connectivity
          if curl -f -s http://localhost:3001 >/dev/null 2>&1; then
            echo '‚úÖ Application responding on root endpoint'
          else
            echo '‚ö†Ô∏è  Application not responding on root endpoint'
          fi
          
          # Clean up test container
          docker stop \$TEST_CONTAINER >/dev/null 2>&1
          echo 'üßπ Test container cleaned up'
        else
          echo '‚ùå Failed to start container in production mode'
        fi
        "
      register: image_compatibility_check
      changed_when: false
      when: image_config_check is defined

    - name: Generate comprehensive image verification report
      ansible.builtin.debug:
        msg: |
          ============================================
          COMPREHENSIVE IMAGE VERIFICATION REPORT
          ============================================
          
          üñºÔ∏è  Image: {{ docker_image }}
          üìÖ Verification Time: {{ ansible_date_time.iso8601 }}
          
          üîç Basic Integrity: {{ '‚úÖ PASSED' if image_integrity_check.rc == 0 else '‚ùå FAILED' }}
          üìä Layer Analysis: {{ '‚úÖ PASSED' if image_layer_check.rc == 0 else '‚ùå FAILED' }}
          üîí Security Check: {{ '‚úÖ PASSED' if image_security_check.rc == 0 else '‚ùå FAILED' }}
          ‚öôÔ∏è  Configuration: {{ '‚úÖ PASSED' if image_config_check.rc == 0 else '‚ùå FAILED' }}
          üåê Compatibility: {{ '‚úÖ PASSED' if image_compatibility_check.rc == 0 else '‚ùå FAILED' }}
          
          üìã Verification Summary:
          - Image integrity: {{ 'PASSED' if image_integrity_check.rc == 0 else 'FAILED' }}
          - Layer optimization: {{ 'PASSED' if image_layer_check.rc == 0 else 'FAILED' }}
          - Security status: {{ 'PASSED' if image_security_check.rc == 0 else 'FAILED' }}
          - Configuration: {{ 'PASSED' if image_config_check.rc == 0 else 'FAILED' }}
          - Production compatibility: {{ 'PASSED' if image_compatibility_check.rc == 0 else 'FAILED' }}
          
          üöÄ Image is {{ 'READY' if (image_integrity_check.rc == 0 and image_layer_check.rc == 0 and image_security_check.rc == 0 and image_config_check.rc == 0 and image_compatibility_check.rc == 0) else 'NOT READY' }} for production deployment
          
                    ============================================

    # IMAGE ROLLBACK CAPABILITY
    - name: Check for available rollback images
      ansible.builtin.command: |
        bash -c "
        echo 'üîÑ Checking for available rollback images...'
        
        # Get current image digest
        CURRENT_DIGEST=\$(docker images --digests {{ docker_image }} --format '{{.Digest}}' | head -1 | sed 's/sha256://')
        echo 'Current Image Digest: \$CURRENT_DIGEST'
        
        # Look for rollback images with timestamps
        ROLLBACK_IMAGES=\$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'rollback-[0-9]{8}-[0-9]{6}' | head -10)
        
                 if [ -n \"\$ROLLBACK_IMAGES\" ]; then
           echo 'Available Rollback Images:'
           echo \$ROLLBACK_IMAGES | tr ' ' '\n' | while read img; do
             CREATED=\$(docker images --format '{{.CreatedAt}}' \$img | head -1)
             SIZE=\$(docker images --format '{{.Size}}' \$img | head -1)
             echo \"  - \$img (\$CREATED, \$SIZE)\"
           done
         else
           echo 'No rollback images found'
         fi
         
         # Look for version-tagged images
         VERSION_IMAGES=\$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E ':v[0-9]+\.[0-9]+\.[0-9]+' | head -5)
         
         if [ -n \"\$VERSION_IMAGES\" ]; then
           echo 'Available Version Images:'
           echo \$VERSION_IMAGES | tr ' ' '\n' | while read img; do
             CREATED=\$(docker images --format '{{.CreatedAt}}' \$img | head -1)
             SIZE=\$(docker images --format '{{.Size}}' \$img | head -1)
             echo \"  - \$img (\$CREATED, \$SIZE)\"
           done
         else
           echo 'No version-tagged images found'
         fi
        
        # Store current digest for potential rollback
        echo \$CURRENT_DIGEST > {{ app_dir }}/current-image-digest.txt
        echo 'Current image digest saved for rollback reference'
        "
      register: rollback_check
      changed_when: false
      when: image_compatibility_check is defined

    - name: Create rollback configuration file
      ansible.builtin.copy:
        dest: "{{ app_dir }}/rollback-config.yml"
        mode: '0644'
        content: |
          # Rollback Configuration for Production Environment
          # Generated on: {{ ansible_date_time.iso8601 }}
          
          current_image: "{{ docker_image }}"
          current_digest: "{{ rollback_check.stdout | regex_search('Current Image Digest: ([a-f0-9]+)', '\\1') | default('unknown') }}"
          deployment_time: "{{ ansible_date_time.iso8601 }}"
          
          # Rollback triggers
          rollback_triggers:
            - health_check_failure: true
            - performance_degradation: true
            - security_vulnerability: true
            - manual_trigger: true
          
          # Rollback procedure
          rollback_steps:
            1. Stop current production container
            2. Pull rollback image from GHCR
            3. Verify rollback image integrity
            4. Start rollback container
            5. Verify application health
            6. Update rollback status
          
          # Available rollback targets
          rollback_targets:
            - type: timestamp_based
              pattern: "rollback-*"
              description: "Time-based rollback images"
            - type: version_based
              pattern: "v*.*.*"
              description: "Semantic version images"
            - type: previous_main
              pattern: "main-*"
              description: "Previous main branch images"
          
          # Rollback verification
          verification_steps:
            - health_check: true
            - connectivity_test: true
            - performance_check: true
            - log_analysis: true

    - name: Create rollback execution script
      ansible.builtin.template:
        src: rollback-execution.sh.j2
        dest: "{{ app_dir }}/rollback-execution.sh"
        mode: '0755'
        backup: true
        vars:
          app_dir: "{{ app_dir }}"
          project_name: "{{ project_name }}"
          docker_image: "{{ docker_image }}"

    - name: Create rollback monitoring script
      ansible.builtin.template:
        src: rollback-monitor.sh.j2
        dest: "{{ app_dir }}/rollback-monitor.sh"
        mode: '0755'
        backup: true
        vars:
          app_dir: "{{ app_dir }}"
          project_name: "{{ project_name }}"
          health_check_url: "http://localhost/health"

    - name: Set up rollback monitoring cron job
      ansible.builtin.cron:
        name: "Rollback Monitoring"
        minute: "*/5"
        job: "{{ app_dir }}/rollback-monitor.sh >> {{ app_dir }}/rollback-monitor.log 2>&1"
        state: present

    - name: Display rollback capability information
      ansible.builtin.debug:
        msg: |
          ============================================
          ROLLBACK CAPABILITY IMPLEMENTED
          ============================================
          
          üöÄ Production environment now includes comprehensive rollback capability
          
          üìÅ Rollback Files Created:
          - {{ app_dir }}/rollback-config.yml (Configuration)
          - {{ app_dir }}/rollback-execution.sh (Execution script)
          - {{ app_dir }}/rollback-monitor.sh (Monitoring script)
          - {{ app_dir }}/current-image-digest.txt (Current image reference)
          
          üîÑ Rollback Triggers:
          - Health check failures
          - Performance degradation
          - Security vulnerabilities
          - Manual triggers
          
          üìä Rollback Targets Available:
          - Timestamp-based rollback images
          - Semantic version images
          - Previous main branch images
          
          ‚ö° Quick Rollback Commands:
          - Manual rollback: {{ app_dir }}/rollback-execution.sh
          - Check status: {{ app_dir }}/rollback-monitor.sh
          - View config: cat {{ app_dir }}/rollback-config.yml
          
          üïê Monitoring: Automatic health checks every 5 minutes
          
          ============================================

      - name: Start Docker Compose services
      command: docker-compose up -d web
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_up
      retries: 3
      delay: 15
      until: docker_up is success
      
    - name: Check if Docker Compose services started successfully
      command: docker-compose ps
      args:
        chdir: "{{ app_dir }}/repo"
      register: docker_ps
      changed_when: false
      
    - name: Display Docker Compose status
      debug:
        var: docker_ps.stdout_lines
      
    - name: Display deployment completion message
      ansible.builtin.debug:
        msg: |
          ============================================
          PRODUCTION DEPLOYMENT COMPLETED SUCCESSFULLY
          ============================================
          
          Application is now available at http://{{ public_ip }}
          
          Deployment Details:
          - Environment: Production
          - Image Source: Image Promotion Workflow
          - Production Image: {{ docker_image }}
          - Status: Deployed and Running
          
          Image Promotion Workflow:
          - Staging ‚Üí Image Promotion ‚Üí Production
          - Manual approval required for promotion
          - Promoted images stored in GHCR
          
          Next Steps:
          1. Monitor application health
          2. Verify SSL certificate (if applicable)
          3. Test production functionality
          4. For updates: Repeat staging ‚Üí promotion ‚Üí production cycle
          
          ============================================

    - name: Configure Nginx worker processes from template
      ansible.builtin.template:
        src: nginx.conf.j2
        dest: /etc/nginx/nginx.conf
        mode: '0644'
        backup: true

    - name: Configure Nginx as reverse proxy from template
      ansible.builtin.template:
        src: nextjs-site.conf.j2
        dest: /etc/nginx/sites-available/nextjs-app
        mode: '0644'
        backup: true

    - name: Enable Nginx site configuration
      file:
        src: /etc/nginx/sites-available/nextjs-app
        dest: /etc/nginx/sites-enabled/nextjs-app
        state: link

    - name: Remove default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      ignore_errors: yes

    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_test
      changed_when: false
      ignore_errors: true

    - name: Display Nginx test results
      debug:
        msg: "{{ nginx_test.stderr_lines }}"
      when: nginx_test.rc != 0

    - name: Restart Nginx
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_test.rc == 0
      register: nginx_restart
      retries: 2
      delay: 5
      until: nginx_restart is success

    - name: Setup firewall (UFW)
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - '22'
        - '80'
        - '443'
        - '6080'
        - '8080'

    - name: Enable UFW
      ufw:
        state: enabled
        policy: deny

    - name: Create enhanced monitoring script from template
      ansible.builtin.template:
        src: monitor.sh.j2
        dest: "{{ app_dir }}/monitor.sh"
        mode: '0755'
        backup: true
          
    - name: Set up monitoring cron job
      cron:
        name: "Monitor dotca-nextjs"
        minute: "*/15"
        job: "{{ app_dir }}/monitor.sh >> {{ app_dir }}/monitoring.log 2>&1"
        state: present

    # Copy additional utility templates for consistency with staging
    - name: Copy Docker cleanup script from template
      ansible.builtin.template:
        src: docker_cleanup.sh.j2
        dest: "{{ app_dir }}/docker_cleanup.sh"
        mode: '0755'
        backup: true

    - name: Copy port verification script from template
      ansible.builtin.template:
        src: port_verification.sh.j2
        dest: "{{ app_dir }}/port_verification.sh"
        mode: '0755'
        backup: true

    - name: Copy logrotate configuration from template
      ansible.builtin.template:
        src: logrotate.conf.j2
        dest: /etc/logrotate.d/dotca-production
        mode: '0644'
        backup: true

# Create a separate play for Let's Encrypt setup
- name: Setup Let's Encrypt with Nginx
  hosts: digitalocean
  become: yes
  vars:
    domain_name: "boximity.ca"
    email_address: "matticem@boximity.ca"
  
  tasks:
    - name: Install Certbot and Nginx plugin
      package:
        name:
          - certbot
          - python3-certbot-nginx
        state: present
      register: certbot_install
      retries: 3
      delay: 5
      until: certbot_install is success

    - name: Check if certificate already exists
      stat:
        path: /etc/letsencrypt/live/{{ domain_name }}/cert.pem
      register: cert_file

    # Check if domain is properly configured in Nginx before requesting a certificate
    - name: Verify domain configuration in Nginx
      ansible.builtin.shell: |
        if [ -f /etc/nginx/sites-available/nextjs-app ]; then
          grep -q "server_name {{ domain_name }}" /etc/nginx/sites-available/nextjs-app || echo "Domain not configured"
        else
          echo "Nginx config not found"
        fi
      register: domain_check
      changed_when: false

    - name: Configure domain in Nginx if needed
      ansible.builtin.replace:
        path: /etc/nginx/sites-available/nextjs-app
        regexp: 'server_name _;'
        replace: 'server_name {{ domain_name }};'
      when: domain_check.stdout == "Domain not configured" or domain_check.stdout == "Nginx config not found"
      register: nginx_domain_update

    - name: Restart Nginx before certificate request
      systemd:
        name: nginx
        state: restarted
        enabled: yes
      when: nginx_domain_update is changed

    # Verify Nginx is responding with the correct domain before obtaining certificate
    - name: Verify Nginx is serving the domain correctly
      ansible.builtin.uri:
        url: http://localhost
        method: GET
        return_content: yes
      register: nginx_check
      ignore_errors: yes

    - name: Debug Nginx response
      debug:
        msg: "Nginx Health Check: {{ nginx_check.status | default('Failed') }}"

    - name: Obtain SSL certificate
      command: >
        certbot --nginx -d {{ domain_name }}
        --non-interactive --agree-tos 
        --email {{ email_address }}
        --redirect
      when: not cert_file.stat.exists and (nginx_check.status | default(0)) == 200
      register: certbot_result
      retries: 2
      delay: 30
      until: certbot_result is success
      
    - name: Log certificate generation results
      debug:
        msg: "Certbot output: {{ certbot_result.stdout_lines | default(['No output']) }}"
      when: not cert_file.stat.exists and certbot_result is defined

    - name: Add cron job for auto-renewal
      cron:
        name: "Let's Encrypt renewal"
        special_time: daily
        job: "certbot renew --quiet --nginx"