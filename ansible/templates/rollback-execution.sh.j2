#!/bin/bash

# Rollback Execution Script for Production Environment
# Generated from template on: {{ ansible_date_time.iso8601 }}

set -euo pipefail

# Configuration
APP_DIR="{{ app_dir }}"
PROJECT_NAME="{{ project_name }}"
CURRENT_IMAGE="{{ docker_image }}"
LOG_FILE="$APP_DIR/rollback-execution.log"
CONFIG_FILE="$APP_DIR/rollback-config.yml"
HEALTH_CHECK_URL="http://localhost/health"
DOCKER_COMPOSE_DIR="$APP_DIR/repo"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to log messages
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to get docker-compose command
get_docker_compose_cmd() {
    if command_exists "docker compose"; then
        echo "docker compose"
    elif command_exists "docker-compose"; then
        echo "docker-compose"
    else
        echo "none"
    fi
}

# Function to display usage
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS] <rollback_target>

Rollback Production Environment

OPTIONS:
    -h, --help              Show this help message
    -f, --force             Force rollback without confirmation
    -v, --verbose           Enable verbose output
    -t, --target <target>   Specify rollback target (image:tag)
    -l, --list              List available rollback targets
    -s, --status            Show current deployment status

ROLLBACK TARGETS:
    - Specific image:tag (e.g., ghcr.io/bxtech/dotca:rollback-20241201-143022-bugfix)
    - Version tag (e.g., ghcr.io/bxtech/dotca:v1.2.3)
    - Previous main (e.g., ghcr.io/bxtech/dotca:main-abc123)
    - 'latest' for most recent rollback image
    - 'previous' for second most recent rollback image

EXAMPLES:
    $0 -l                           # List available rollback targets
    $0 -t ghcr.io/bxtech/dotca:v1.2.3  # Rollback to specific version
    $0 -t latest                   # Rollback to most recent rollback image
    $0 -f -t previous              # Force rollback to previous image

EOF
}

# Function to list available rollback targets
list_rollback_targets() {
    log_message "Listing available rollback targets..."

    print_status $BLUE "ðŸ” Available Rollback Targets:"

    # Check for rollback images
    ROLLBACK_IMAGES=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'rollback-[0-9]{8}-[0-9]{6}' | head -10)
    if [ -n "$ROLLBACK_IMAGES" ]; then
        print_status $GREEN "ðŸ“… Timestamp-based Rollback Images:"
        echo "$ROLLBACK_IMAGES" | tr ' ' '\n' | while read img; do
            CREATED=$(docker images --format '{{.CreatedAt}}' "$img" | head -1)
            SIZE=$(docker images --format '{{.Size}}' "$img" | head -1)
            echo "  - $img ($CREATED, $SIZE)"
        done
    fi

    # Check for version images
    VERSION_IMAGES=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E ':v[0-9]+\.[0-9]+\.[0-9]+' | head -5)
    if [ -n "$VERSION_IMAGES" ]; then
        print_status $GREEN "ðŸ·ï¸  Version-tagged Images:"
        echo "$VERSION_IMAGES" | tr ' ' '\n' | while read img; do
            CREATED=$(docker images --format '{{.CreatedAt}}' "$img" | head -1)
            SIZE=$(docker images --format '{{.Size}}' "$img" | head -1)
            echo "  - $img ($CREATED, $SIZE)"
        done
    fi

    # Check for previous main images
    MAIN_IMAGES=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E ':main-[a-f0-9]+' | head -5)
    if [ -n "$MAIN_IMAGES" ]; then
        print_status $GREEN "ðŸŒ¿ Previous Main Branch Images:"
        echo "$MAIN_IMAGES" | tr ' ' '\n' | while read img; do
            CREATED=$(docker images --format '{{.CreatedAt}}' "$img" | head -1)
            SIZE=$(docker images --format '{{.Size}}' "$img" | head -1)
            echo "  - $img ($CREATED, $SIZE)"
        done
    fi

    if [ -z "$ROLLBACK_IMAGES$VERSION_IMAGES$MAIN_IMAGES" ]; then
        print_status $YELLOW "âš ï¸  No rollback targets found"
    fi
}

# Function to show current deployment status
show_status() {
    log_message "Showing current deployment status..."

    print_status $BLUE "ðŸ“Š Current Deployment Status:"

    # Current image info
    CURRENT_DIGEST=$(docker images --digests "$CURRENT_IMAGE" --format '{{.Digest}}' | head -1 | sed 's/sha256://')
    CURRENT_SIZE=$(docker images --format '{{.Size}}' "$CURRENT_IMAGE" | head -1)
    CURRENT_CREATED=$(docker images --format '{{.CreatedAt}}' "$CURRENT_IMAGE" | head -1)

    echo "ðŸ–¼ï¸  Current Image: $CURRENT_IMAGE"
    echo "ðŸ”‘ Digest: $CURRENT_DIGEST"
    echo "ðŸ“ Size: $CURRENT_SIZE"
    echo "ðŸ“… Created: $CURRENT_CREATED"

    # Container status
    cd "$DOCKER_COMPOSE_DIR" || exit 1
    DOCKER_COMPOSE_CMD=$(get_docker_compose_cmd)

    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        print_status $BLUE "ðŸ³ Container Status:"
        $DOCKER_COMPOSE_CMD ps
    fi

    # Health check
    print_status $BLUE "â¤ï¸  Health Check:"
    if curl -f -s "$HEALTH_CHECK_URL" >/dev/null 2>&1; then
        print_status $GREEN "âœ… Application is healthy"
    else
        print_status $RED "âŒ Application health check failed"
    fi
}

# Function to validate rollback target
validate_rollback_target() {
    local target=$1

    # Handle special targets
    case "$target" in
        "latest")
            # Find most recent rollback image
            target=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'rollback-[0-9]{8}-[0-9]{6}' | head -1)
            if [ -z "$target" ]; then
                print_status $RED "âŒ No rollback images found for 'latest' target"
                return 1
            fi
            print_status $YELLOW "ðŸ”„ Using latest rollback image: $target"
            ;;
        "previous")
            # Find second most recent rollback image
            target=$(docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'rollback-[0-9]{8}-[0-9]{6}' | head -2 | tail -1)
            if [ -z "$target" ]; then
                print_status $RED "âŒ No previous rollback image found"
                return 1
            fi
            print_status $YELLOW "ðŸ”„ Using previous rollback image: $target"
            ;;
    esac

    # Check if target image exists locally
    if docker images "$target" --format '{{.Repository}}:{{.Tag}}' | grep -q "$target"; then
        print_status $GREEN "âœ… Rollback target found locally: $target"
        return 0
    fi

    # Check if target image exists in registry
    print_status $YELLOW "ðŸ” Checking if target image exists in registry..."
    if docker manifest inspect "$target" >/dev/null 2>&1; then
        print_status $GREEN "âœ… Rollback target found in registry: $target"
        return 0
    fi

    print_status $RED "âŒ Rollback target not found: $target"
    return 1
}

# Function to perform rollback
perform_rollback() {
    local target=$1
    local force=$2

    log_message "Starting rollback to: $target"

    print_status $BLUE "ðŸš€ Starting Production Rollback..."
    print_status $YELLOW "âš ï¸  This will replace the current production deployment"

    if [ "$force" != "true" ]; then
        read -p "Are you sure you want to continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_status $YELLOW "âŒ Rollback cancelled by user"
            exit 0
        fi
    fi

    # Create backup of current deployment
    print_status $BLUE "ðŸ’¾ Creating backup of current deployment..."
    CURRENT_BACKUP="$APP_DIR/backup-$(date +%Y%m%d-%H%M%S)"
    mkdir -p "$CURRENT_BACKUP"

    # Save current docker-compose state
    cd "$DOCKER_COMPOSE_DIR" || exit 1
    DOCKER_COMPOSE_CMD=$(get_docker_compose_cmd)

    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        $DOCKER_COMPOSE_CMD ps > "$CURRENT_BACKUP/container-status.txt" 2>&1 || true
        $DOCKER_COMPOSE_CMD logs web > "$CURRENT_BACKUP/container-logs.txt" 2>&1 || true
    fi

    # Save current image info
    docker images "$CURRENT_IMAGE" --format '{{.Repository}}:{{.Tag}} {{.Digest}} {{.Size}} {{.CreatedAt}}' > "$CURRENT_BACKUP/current-image.txt" 2>&1 || true

    print_status $GREEN "âœ… Backup created at: $CURRENT_BACKUP"

    # Stop current production container
    print_status $BLUE "ðŸ›‘ Stopping current production container..."
    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        $DOCKER_COMPOSE_CMD down web || true
    fi

    # Pull rollback image if not local
    if ! docker images "$target" --format '{{.Repository}}:{{.Tag}}' | grep -q "$target"; then
        print_status $BLUE "ðŸ“¥ Pulling rollback image from registry..."
        docker pull "$target" || {
            print_status $RED "âŒ Failed to pull rollback image: $target"
            print_status $BLUE "ðŸ”„ Attempting to restore previous deployment..."
            restore_previous_deployment
            exit 1
        }
    fi

    # Update docker-compose.yml with rollback image
    print_status $BLUE "ðŸ“ Updating docker-compose.yml with rollback image..."
    sed -i.bak "s|image:.*|image: $target|" "$DOCKER_COMPOSE_DIR/docker-compose.yml"

    # Start rollback container
    print_status $BLUE "ðŸš€ Starting rollback container..."
    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        $DOCKER_COMPOSE_CMD up -d web || {
            print_status $RED "âŒ Failed to start rollback container"
            print_status $BLUE "ðŸ”„ Attempting to restore previous deployment..."
            restore_previous_deployment
            exit 1
        }
    fi

    # Wait for container to be ready
    print_status $BLUE "â³ Waiting for rollback container to be ready..."
    sleep 15

    # Verify rollback deployment
    print_status $BLUE "ðŸ” Verifying rollback deployment..."
    if ! verify_rollback_deployment "$target"; then
        print_status $RED "âŒ Rollback verification failed"
        print_status $BLUE "ðŸ”„ Attempting to restore previous deployment..."
        restore_previous_deployment
        exit 1
    fi

    # Update rollback status
    print_status $BLUE "ðŸ“ Updating rollback status..."
    update_rollback_status "$target" "success"

    print_status $GREEN "âœ… Rollback completed successfully!"
    print_status $BLUE "ðŸ–¼ï¸  Production now running: $target"
    print_status $YELLOW "ðŸ“ Backup available at: $CURRENT_BACKUP"

    log_message "Rollback completed successfully to: $target"
}

# Function to verify rollback deployment
verify_rollback_deployment() {
    local target=$1

    # Check container is running
    cd "$DOCKER_COMPOSE_DIR" || return 1
    DOCKER_COMPOSE_CMD=$(get_docker_compose_cmd)

    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        if ! $DOCKER_COMPOSE_CMD ps | grep -q "Up"; then
            print_status $RED "âŒ Rollback container is not running"
            return 1
        fi
    fi

    # Health check
    local retries=0
    local max_retries=10

    while [ $retries -lt $max_retries ]; do
        if curl -f -s "$HEALTH_CHECK_URL" >/dev/null 2>&1; then
            print_status $GREEN "âœ… Health check passed"
            break
        fi

        retries=$((retries + 1))
        print_status $YELLOW "â³ Health check attempt $retries/$max_retries..."
        sleep 5
    done

    if [ $retries -eq $max_retries ]; then
        print_status $RED "âŒ Health check failed after $max_retries attempts"
        return 1
    fi

    # Basic connectivity test
    if curl -f -s "http://localhost:8080" >/dev/null 2>&1; then
        print_status $GREEN "âœ… Application responding on root endpoint"
    else
        print_status $YELLOW "âš ï¸  Application not responding on root endpoint (continuing...)"
    fi

    return 0
}

# Function to restore previous deployment
restore_previous_deployment() {
    print_status $YELLOW "ðŸ”„ Restoring previous deployment..."

    # Restore docker-compose.yml
    if [ -f "$DOCKER_COMPOSE_DIR/docker-compose.yml.bak" ]; then
        mv "$DOCKER_COMPOSE_DIR/docker-compose.yml.bak" "$DOCKER_COMPOSE_DIR/docker-compose.yml"
    fi

    # Start previous container
    cd "$DOCKER_COMPOSE_DIR" || exit 1
    DOCKER_COMPOSE_CMD=$(get_docker_compose_cmd)

    if [ "$DOCKER_COMPOSE_CMD" != "none" ]; then
        $DOCKER_COMPOSE_CMD up -d web || {
            print_status $RED "âŒ Failed to restore previous deployment"
            exit 1
        }
    fi

    print_status $GREEN "âœ… Previous deployment restored"
}

# Function to update rollback status
update_rollback_status() {
    local target=$1
    local status=$2

    local status_file="$APP_DIR/rollback-status.json"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    cat > "$status_file" << EOF
{
  "last_rollback": {
    "target": "$target",
    "status": "$status",
    "timestamp": "$timestamp",
    "previous_image": "$CURRENT_IMAGE"
  },
  "rollback_history": [
    {
      "target": "$target",
      "status": "$status",
      "timestamp": "$timestamp",
      "previous_image": "$CURRENT_IMAGE"
    }
  ]
}
EOF

    print_status $GREEN "âœ… Rollback status updated"
}

# Main execution
main() {
    local force=false
    local verbose=false
    local target=""
    local list_targets=false
    local show_status_flag=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -f|--force)
                force=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -t|--target)
                target="$2"
                shift 2
                ;;
            -l|--list)
                list_targets=true
                shift
                ;;
            -s|--status)
                show_status_flag=true
                shift
                ;;
            *)
                if [ -z "$target" ]; then
                    target="$1"
                else
                    print_status $RED "âŒ Invalid argument: $1"
                    show_usage
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Enable verbose mode if requested
    if [ "$verbose" = true ]; then
        set -x
    fi

    # Check if we're in the right directory
    if [ ! -d "$DOCKER_COMPOSE_DIR" ]; then
        print_status $RED "âŒ Docker Compose directory not found: $DOCKER_COMPOSE_DIR"
        exit 1
    fi

    # Check if docker-compose is available
    DOCKER_COMPOSE_CMD=$(get_docker_compose_cmd)
    if [ "$DOCKER_COMPOSE_CMD" = "none" ]; then
        print_status $RED "âŒ Docker Compose not available"
        exit 1
    fi

    # Handle different modes
    if [ "$list_targets" = true ]; then
        list_rollback_targets
        exit 0
    fi

    if [ "$show_status_flag" = true ]; then
        show_status
        exit 0
    fi

    if [ -z "$target" ]; then
        print_status $RED "âŒ Rollback target not specified"
        show_usage
        exit 1
    fi

    # Validate rollback target
    if ! validate_rollback_target "$target"; then
        exit 1
    fi

    # Perform rollback
    perform_rollback "$target" "$force"
}

# Run main function with all arguments
main "$@"
